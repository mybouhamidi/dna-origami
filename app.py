import os
import random
import re
import sys
import json
from typing import Type
import yaml

# Import QApplication and the required widgets from PyQt5.QtWidgets
from PyQt5.QtCore import Qt, QSize, QRegExp, QRect
from PyQt5.QtGui import QPixmap, QIcon, QRegExpValidator
from PyQt5.QtWidgets import (
    QFormLayout,
    QMainWindow,
    QTabWidget,
    QVBoxLayout,
    QHBoxLayout,
    QFrame,
    QLabel,
    QPushButton,
    QLineEdit,
    QErrorMessage,
    QWidget,
    QScrollArea,
    QGroupBox,
    QFileDialog,
    QGraphicsPixmapItem,
    QInputDialog,
    QProgressBar,
    QGraphicsScene,
    QCheckBox,
    QMessageBox,
    QGraphicsView,
    QApplication,
)
from qtrangeslider import QLabeledRangeSlider


# Import pandas and numpy for data manipulation
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.patches import Rectangle
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5 import NavigationToolbar2QT

# Import mfold required libraries
from mfold_library import Mfold, Region, Strand
from genetic import Sequence


def clear_files() -> None:
    """
    This function is called to clear the files generated by the Mfold software
    """
    extensions = [
        ".log",
        ".seq",
        ".ct",
        ".det",
        ".out",
        ".pnt",
        ".sav",
        ".test",
        ".cmd",
        ".aux",
        ".con",
    ]
    current_dir = os.getcwd()
    dir_items = os.listdir(current_dir)

    for item in dir_items:
        for extension in extensions:
            if item.endswith(extension):
                os.remove(os.path.join(current_dir, item))


def complement(strand: str) -> str:
    complemented = (
        strand[::-1].replace("C", "temp").replace("G", "C").replace("temp", "G")
    )
    complemented = (
        complemented.replace("A", "temp").replace("T", "A").replace("temp", "T")
    )
    return complemented


def set_constraints(self, region1: list, region2: list) -> str:
    """
    This function is called to set constraints for the energy calculation generated by the Mfold software
    """
    data = gc_content(self)
    constraint = None
    if region1 == region2:
        constraint = None

    else:
        flag = False

        if region1[-1] == region2[-1]:
            flag = True

        region1 = dict.fromkeys(region1)
        region2 = dict.fromkeys(region2[::-1])
        length = 1
        for key in region1.keys():
            upper_index = length + len(data[key]["bases"]) - 1
            region1[key] = f"{length}-{upper_index}"
            length += len(data[key]["bases"])

        length += 3
        for key in region2.keys():
            upper_index = length + len(data[key]["bases"]) - 1
            region2[key] = f"{length}-{upper_index}"
            length += len(data[key]["bases"])

        shared_list = [k for k in region1.keys() if k in region2.keys()]
        complementary_1 = [
            (k, k.swapcase()) for k in region1.keys() if k.swapcase() in region1.keys()
        ]
        complementary_2 = [
            (k, k.swapcase()) for k in region2.keys() if k.swapcase() in region2.keys()
        ]

        if len(shared_list) < 2:
            for key in shared_list:
                if constraint is None:
                    constraint = f"P {region1[key]} {region2[key]}\n"
                    for value in complementary_1:
                        constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    for value in complementary_2:
                        constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                else:
                    constraint += f"P {region1[key]} {region2[key]}\n"
                    for value in complementary_1:
                        constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    for value in complementary_2:
                        constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
        else:
            if flag:
                _min = region1[shared_list[0]].split("-")[0]
                _max = region2[shared_list[0]].split("-")[1]
                constraint = f"P {_min}-{_max} {_min}-{_max}\n"
                for value in complementary_1:
                    constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                for value in complementary_2:
                    constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
            else:
                _min_i = region1[shared_list[0]].split("-")[0]
                _max_i = region1[shared_list[-1]].split("-")[1]
                _max_j = region2[shared_list[0]].split("-")[1]
                _min_j = region2[shared_list[-1]].split("-")[0]
                constraint = f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                for value in complementary_1:
                    constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                for value in complementary_2:
                    constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"


def parse_ct_file(self, data: dict, i: int, j: int) -> dict:
    reset_flag = False
    try:
        with open(f"{i}_{j}.ct", "r") as configfile:
            counter = 0
            _max = 0
            saved = {"letter": [], "index": [], "end": []}
            for line in configfile:
                try:
                    if counter > (
                        len(self.strand[i].bases) + len(self.strand[j].bases) + 4
                    ):
                        break
                    if reset_flag:
                        if int(line[26:30]) == 0:
                            if counter <= len(self.strand[i].bases):
                                end = counter
                            else:
                                end = counter - 3

                            saved["letter"].append(letter)
                            saved["end"].append(end)
                            reset_flag = False
                        else:
                            letter += line[7:8]

                    elif int(line[26:30]) > _max:
                        letter = ""
                        _max = int(line[26:30])
                        reset_flag = True
                        letter += line[7:8]

                        if counter <= len(self.strand[i].bases):
                            index = counter
                        else:
                            index = counter - 3

                        saved["index"].append(index)

                    elif int(line[26:30]) != 0 and int(line[26:30]) < _max:
                        letter = ""
                        reset_flag = True
                        letter += line[7:8]

                        if counter <= len(self.strand[i].bases):
                            index = counter
                        else:
                            index = counter - 3

                        saved["index"].append(index)

                    counter += 1
                except ValueError:
                    counter += 1
                    pass

            letter = max(saved["letter"], key=len)

            data[f"{i}{j}"]["energy"] = self.energy[i][j]
            data[f"{i}{j}"]["letter"] = letter
            data[f"{i}{j}"]["max"] = _max
            data[f"{i}{j}"]["index_app"] = saved["index"][saved["letter"].index(letter)]
            data[f"{i}{j}"]["end"] = saved["end"][saved["letter"].index(letter)]
            data[f"{i}{j}"]["shape"] = f"{i}_{j}.png"

    except FileNotFoundError:
        data[f"{i}{j}"]["energy"] = 0
        data[f"{i}{j}"]["letter"] = None
        data[f"{i}{j}"]["max"] = 0
        data[f"{i}{j}"]["index_app"] = 0
        data[f"{i}{j}"]["end"] = 0
        data[f"{i}{j}"]["shape"] = None
        pass


def process_mfold_files(self):
    """
    This function creates a dataframe by reading the ".ct" files generated by Mfold and storing information relative to desired regions.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.energy : Matrix used to store the energy loss returned by the Mfold software
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
    """
    data = {}
    for row in range(len(self.energy)):
        for column in range(len(self.energy)):
            data[f"{row}{column}"] = {}
            parse_ct_file(self, data, row, column)
    df = pd.DataFrame.from_dict(data)
    self.thief = df


def manipulate_highlights(self):
    """
    This function is used to manipulate the dataframe generated by process_mfold_files() and highlights the specific fields that are responsable for
    the energy loss.

    Args:
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.header : Region identifiers provided by the user in user_input()
            self.index : Indices of the fields of interest
            self.highlighted : Fields of interest to be highlighted
            self.field : Fields generated by the user in user_input()
    """
    transposed_data = self.thief.transpose()

    for column, energy in enumerate(transposed_data["energy"]):
        region_identifiers = []
        if energy == transposed_data["energy"].max():
            end_of_highlighted_region = transposed_data["end"][column]
            start_of_highlighted_region = transposed_data["index_app"][column]

            if transposed_data["end"][column] - 1 <= len(
                self.strand[
                    int(
                        transposed_data["shape"][column]
                        .replace(".png", "")
                        .split("_")[0]
                    )
                ].bases
            ):
                strand_index = int(
                    transposed_data["shape"][column].replace(".png", "").split("_")[0]
                )

            else:
                strand_index = int(
                    transposed_data["shape"][column].replace(".png", "").split("_")[1]
                )
                end_of_highlighted_region = end_of_highlighted_region - len(
                    self.strand[
                        int(
                            transposed_data["shape"][column]
                            .replace(".png", "")
                            .split("_")[0]
                        )
                    ].bases
                )
                start_of_highlighted_region = start_of_highlighted_region - len(
                    self.strand[
                        int(
                            transposed_data["shape"][column]
                            .replace(".png", "")
                            .split("_")[0]
                        )
                    ].bases
                )

            region_identifiers = [
                self.regions[strand_index].split("--")[_]
                for _ in range(len(self.regions[strand_index].split("--")))
            ]

            data = gc_content(self)
            length_of_regions = [
                len(data[region_identifiers[_]]["bases"])
                for _ in range(len(region_identifiers))
            ]

            indices = []
            for c in range(len(region_identifiers)):
                _ = 0
                while region_identifiers[c] != self.header[_]:
                    _ += 1
                indices.append(_)

            bases = self.strand[strand_index].bases

            if start_of_highlighted_region > end_of_highlighted_region:
                highlighted_strand = str(
                    f"{bases[:start_of_highlighted_region-1]}[{bases[start_of_highlighted_region-1:]}]"
                )
            else:
                highlighted_strand = str(
                    f"{bases[:start_of_highlighted_region-1]}[{bases[start_of_highlighted_region-1:end_of_highlighted_region-1]}]{bases[end_of_highlighted_region-1:]}"
                )

            single_highlighted_regions = []
            counter = 0

            while counter < len(length_of_regions):
                if (
                    "]" in highlighted_strand[: length_of_regions[counter] + 2]
                    and "[" in highlighted_strand[: length_of_regions[counter] + 2]
                ):
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter] + 2]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] + 2 :
                    ]
                elif (
                    "]" in highlighted_strand[: length_of_regions[counter] + 1]
                    or "[" in highlighted_strand[: length_of_regions[counter] + 1]
                ):
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter] + 1]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] + 1 :
                    ]
                else:
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter]]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] :
                    ]
                counter += 1

            keep_region = False
            counter = 0
            while counter < len(single_highlighted_regions):
                if (
                    "[" in single_highlighted_regions[counter]
                    and "]" in single_highlighted_regions[counter]
                ) or "]" in single_highlighted_regions[counter]:
                    keep_region = False
                elif "[" in single_highlighted_regions[counter]:
                    keep_region = True
                else:
                    if not keep_region:
                        indices.pop(counter)
                        single_highlighted_regions.pop(counter)
                counter += 1

            for i in range(len(self.thief.columns)):
                if (
                    self.thief.loc["energy"][i] == energy
                    and self.thief.loc["shape"][i] == transposed_data["shape"][column]
                    and len(self.shape) < 2
                ):
                    self.shape.append(transposed_data["shape"][column])
                    label = self.thief.columns.values.tolist()
                    self.thief = self.thief.drop(labels=[label[i]], axis=1)
                    break

    return single_highlighted_regions, indices


def gc_content(self) -> dict:
    """
    This function is used to measure the occurences of Gs or Cs in a given strand and also helps delimit and call specific region identifiers.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.population_size : Length of a given region provided by the user in user_input()
            self.header : Region identifiers provided by the user in user_input()
            gc : an empty list to store the gc content measured by this function

    Returns:
            data : a dictionary containing region identifiers as keys and their respective sequences as items
            gc : gc content measured throughout each sequence(# of Gs and # of Cs)
    """
    gci = 0
    regions = []

    full_sequence = "".join(list(self.strand[i].bases for i in range(len(self.strand))))

    for region in self.regions:
        regions += region.split("--")

    struct = {self.header[_]: self.population_size[_] for _ in range(len(self.header))}

    counter = 0
    bases = []
    index = 0
    while counter < len(full_sequence):
        bases.append(full_sequence[counter : counter + struct[regions[index]]])
        counter += struct[regions[index]]
        index += 1

    data = {regions[m]: {"bases": bases[m], "gc": 0} for m in range(len(regions))}

    for header, base in data.items():
        gci += base["bases"].count("G")
        gci += base["bases"].count("C")
        data[header]["gc"] = gci
        gci = 0

    return data


class Structure_viewer(QMainWindow):
    def _init_(self, main):
        super().__init__()
        self.parent = main

    def input(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Input Structure")
        self.main_layout = QTabWidget()

        if self.parent().strand == []:
            self.render_new_input()

        else:
            self.render_existing_input()

    def render_new_input(self):
        self.main_layout.setFixedSize(500, 150)
        self.vbox = QVBoxLayout()
        self.field = QLineEdit()
        self.yes = QPushButton("Confirm")
        self.yes.setFixedSize(70, 35)

        self.field.editingFinished.connect(self.input_structure)
        self.yes.clicked.connect(self.closing)

        self.vbox.addWidget(QLabel("Enter your desired shape:"))
        self.vbox.addWidget(QLabel("(for example: a25 B25, b25 C25, c25 D25, d25 A25)"))
        self.vbox.addWidget(self.field)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)
        self.setFixedSize(500, 150)
        self.move(600, 350)
        self.show()

    def render_existing_input(self):
        self.main_layout.setFixedSize(500, 250)
        self.vbox = QVBoxLayout()
        self.structure_label = QLabel()

        hbox = QHBoxLayout()
        hbox.addWidget(self.structure_label)

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(hbox)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)

        self.yes = QPushButton("Confirm")
        self.yes.setFixedSize(70, 35)

        self.field = QLineEdit()
        self.line = QFrame()
        self.line.setGeometry(QRect(60, 110, 751, 20))
        self.line.setFrameShape(QFrame.HLine)
        self.line.setFrameShadow(QFrame.Sunken)

        self.yes.clicked.connect(self.closing)
        self.field.editingFinished.connect(self.input_structure)

        self.vbox.addWidget(QLabel(f"The current structure is :"))

        self.structure_label.setText(f"{self.parent().raw_structure}")
        self.structure_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        self.vbox.addWidget(self.scroll)
        self.vbox.addWidget(self.line)
        self.vbox.addWidget(
            QLabel("For a new structure, please enter your desired shape")
        )
        self.vbox.addWidget(QLabel("(for example: a25 B25, b25 C25, c25 D25, d25 A25)"))
        self.vbox.addWidget(self.field)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)

        self.setFixedSize(500, 250)
        self.move(600, 350)
        self.show()

    def input_structure(self):
        if self.field.text() != "":
            self.parent().raw_structure = self.field.text()

    def closing(self):
        """
        This event handler is called during the closing off the pop-up to adjust GC range or run the randomization with the current GC range
        """
        if self.field.text() == "":
            error = QErrorMessage(self)
            error.showMessage("Please provide a structure")
            self.parent().raw_structure = None
        else:
            self.close()
            self.parent().user_input()


class Export_message(QMainWindow):
    """
    This class creates a widget to provide the user with a window to visualize the configuration and save it
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def export(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Save configuration/oligos")
        self.main_layout = QWidget()
        self.vbox = QVBoxLayout()

        self.scroll_configuration = QScrollArea()
        self.scroll_configuration.setStyleSheet("border: none")

        self.configuration_message_box = QVBoxLayout()
        self.configuration_group = QGroupBox()
        self.configuration_group.setStyleSheet("border: none")
        self.configuration_group.setLayout(self.configuration_message_box)
        self.scroll_configuration.setWidget(self.configuration_group)
        self.scroll_configuration.setWidgetResizable(True)

        self.yes_configuration = QPushButton("Export configuration")
        self.yes_configuration.setFixedSize(170, 35)
        self.yes_configuration.clicked.connect(self.save_configuration)

        base = ""
        data = gc_content(self.parent())

        for index in range(len(self.parent().strand)):
            length_of_region = len(self.parent().regions[index].split("--"))
            for _ in range(length_of_region):
                if _ == 0:
                    base = data[self.parent().regions[index].split("--")[_]]["bases"]
                else:
                    base += (
                        "--"
                        + data[self.parent().regions[index].split("--")[_]]["bases"]
                    )

            row = QLabel(f"{self.parent().regions[index]}: {base}")
            row.setTextInteractionFlags(Qt.TextSelectableByMouse)
            self.configuration_message_box.addWidget(row)

        self.vbox.addWidget(
            QLabel("This section saves the current configuration for future use")
        )
        self.vbox.addWidget(self.scroll_configuration)
        self.vbox.addWidget(self.yes_configuration)

        self.line = QFrame()
        self.line.setGeometry(QRect(60, 110, 751, 20))
        self.line.setFrameShape(QFrame.HLine)
        self.line.setFrameShadow(QFrame.Sunken)

        self.vbox.addWidget(self.line)

        self.scroll_oligos = QScrollArea()
        self.scroll_oligos.setStyleSheet("border: none")

        self.oligos_message_box = QVBoxLayout()
        self.oligos_group = QGroupBox()
        self.oligos_group.setStyleSheet("border: none")
        self.oligos_group.setLayout(self.oligos_message_box)
        self.scroll_oligos.setWidget(self.oligos_group)
        self.scroll_oligos.setWidgetResizable(True)

        self.yes_oligos = QPushButton("Export oligos")
        self.yes_oligos.setFixedSize(170, 35)
        self.yes_oligos.clicked.connect(self.save_oligos)

        for _ in range(len(self.parent().regions)):
            row = QLabel(f"{self.parent().regions[_]}: {self.parent().strand[_].bases}")
            row.setTextInteractionFlags(Qt.TextSelectableByMouse)
            self.oligos_message_box.addWidget(row)

        self.vbox.addWidget(QLabel("This section saves the current oligos"))
        self.vbox.addWidget(self.scroll_oligos)
        self.vbox.addWidget(self.yes_oligos)

        self.main_layout.setLayout(self.vbox)

        self.setCentralWidget(self.main_layout)
        self.move(300, 300)
        self.main_layout.adjustSize()
        self.show()
        del data

    def save_configuration(self):
        """
        This event handler is called when the user wants to save the configuration and specify the filename
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            params = {}

            data = gc_content(self.parent())

            self.parent().input_sequence = {
                self.parent().header[_]: data[self.parent().header[_]]["bases"]
                for _ in range(len(self.parent().header))
            }

            params["raw_structure"] = self.parent().raw_structure
            params["mfold_command"] = "./mfold_quik"
            params["boltzmann_factor"] = 1
            params["fixed_regions"] = self.parent().fixed_regions
            params["input_sequence_definitions"] = self.parent().input_sequence
            params["energy_matrix"] = self.parent().energy
            try:
                with open(str(filename[0] + ".dat"), "w") as configfile:
                    yaml.dump(params, configfile)
            except FileNotFoundError:
                pass

            del data
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")

    def save_oligos(self):
        """
        This event handler is called when the user wants to save the oligos and specify the filename
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            try:
                message = {
                    self.parent().regions[_]: self.parent().strand[_].bases
                    for _ in range(len(self.parent().regions))
                }

                with open(str(filename[0] + ".dat"), "w") as configfile:
                    export = {
                        key.replace("--", ""): value for key, value in message.items()
                    }
                    yaml.dump(export, configfile)

            except FileNotFoundError:
                pass
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")


class Paint_structure(QMainWindow):
    """
    This class creates a widget to provide the user with a structure viewer to visualize the sequence's binding
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def paint(self, x, y):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Structure viewer")
        self._zoom = 0
        self.tabs = QTabWidget()
        self.tabs.setFixedSize(1200, 700)

        current_dir = os.getcwd()
        files = os.listdir(current_dir)

        for file in files:
            if file.endswith(f"{y}_{x}.png"):
                label = QLabel(
                    f"This is the interaction between {self.parent().regions[y]} (from 1 to {len(self.parent().strand[y].bases) + 1}) and {self.parent().regions[x]} (from {len(self.parent().strand[y].bases) + 1} to {len(self.parent().strand[y].bases) + len(self.parent().strand[x].bases)})({file})"
                )

                pixmap = QPixmap(file)
                item = QGraphicsPixmapItem(pixmap)
                scene = QGraphicsScene(self)
                scene.addItem(item)
                self.view = QGraphicsView()
                self.view.setScene(scene)

                tab = QWidget()
                tab.layout = QVBoxLayout()
                tab.layout.addWidget(label)
                tab.layout.addWidget(self.view)
                tab.setLayout(tab.layout)
                self.tabs.addTab(
                    tab, f"{self.parent().regions[y]} and {self.parent().regions[x]}"
                )

                self.setCentralWidget(self.tabs)

                self.setFixedSize(1200, 700)
                self.move(100, 100)
                self.show()
                break

    def keyPressEvent(self, event):
        """
        Allowing zooming capabilites for the structure viewer
        """
        if event.key() == 43:  #  or "+" key
            self._zoom = 1.25
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 45:  #  or "-" key
            self._zoom = 0.8
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 72:  #  or "h" key
            self.view.fitInView(self.view.sceneRect(), Qt.KeepAspectRatio)


class DNA_origami(QWidget):
    """
    This class creates the main widget for this application
    """

    def __init__(self):
        super().__init__()
        self.header = []
        self.check = []
        self.fixed_regions = {}
        self.label = []
        self.regions = []
        self.population_size = []
        self.index = []
        self.input_sequence = {}
        self.field = []
        self.raw_structure = None
        self.automate = False
        self.iterator = 0
        self.counter = 0
        self.thief = None
        self.gc_max = 0.6
        self.gc_min = 0.4
        self.strand = []
        self.shape = []
        self.highlighted = []
        self.energy = []
        self.stability = []
        self.max = 0
        self.gc_range_changed = False
        self.initUI()

    def initUI(self):
        """
        This function defines the display of the main widget and event bindings
        """
        self.btn1 = QPushButton("Structure")
        self.btn1.setFixedSize(150, 70)
        self.btn1.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn1.clicked.connect(self.input)

        self.btn3 = QPushButton("Calculate" + "\n" + "energy")
        self.btn3.setFixedSize(150, 70)
        self.btn3.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn3.clicked.connect(self.calculate)

        self.btn4 = QPushButton()
        self.btn4.setFixedSize(70, 70)
        self.btn4.setIcon(QIcon("assets/download-solid.svg"))
        self.btn4.setIconSize(QSize(30, 30))
        self.btn4.setToolTip("Save configuration")
        self.btn4.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn4.clicked.connect(self.export)
        self.btn5 = QPushButton()
        self.btn5.setFixedSize(70, 70)
        self.btn5.setIcon(QIcon("assets/upload-solid.svg"))
        self.btn5.setIconSize(QSize(30, 30))
        self.btn5.setToolTip("Upload configuration")
        self.btn5.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn7 = QPushButton()
        self.btn7.setFixedSize(40, 40)
        self.btn7.setToolTip("Export data")
        self.btn7.setIcon(QIcon("assets/save-solid.svg"))
        self.btn7.setIconSize(QSize(20, 20))
        self.btn7.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn8 = QPushButton("Optimize")
        self.btn8.setFixedSize(150, 70)
        self.btn8.setIconSize(QSize(30, 30))
        self.btn8.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn9 = QPushButton("")
        self.btn9.setFixedSize(70, 70)
        self.btn9.setIcon(QIcon("assets/sync-solid.svg"))
        self.btn9.setIconSize(QSize(30, 30))
        self.btn9.setIconSize(QSize(30, 30))
        self.btn9.setToolTip("Calculate and optimize")
        self.btn9.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )

        self.btn10 = QPushButton()
        self.btn10.setFixedSize(40, 40)
        self.btn10.setToolTip("Rescale graph")
        self.btn10.setIcon(QIcon("assets/scale.png"))
        self.btn10.setIconSize(QSize(20, 20))
        self.btn10.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )

        self.btn5.clicked.connect(self.load)
        self.btn7.clicked.connect(self.output_data)
        self.btn8.clicked.connect(self.randomize_strand)
        self.btn9.clicked.connect(self.loop_calculation)
        self.btn10.clicked.connect(self.user_max)

        self.gc_range_picker = QLabeledRangeSlider()
        self.gc_range_picker.setRange(int(self.gc_min * 100), int(self.gc_max * 100))
        self.gc_range_picker.setMinimum(0)
        self.gc_range_picker.setMaximum(100)
        self.gc_range_picker.setTickInterval(10)
        self.gc_range_picker.setOrientation(Qt.Horizontal)
        self.gc_range_picker.valueChanged.connect(self._on_gc_range_changed)

        self.tabs = QTabWidget()
        self.tabs.setFixedSize(500, 570)

        self.canvas = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.canvas.setFixedSize(490, 450)
        toolbar_1 = NavigationToolbar2QT(self.canvas, self)
        horizontal_toolbar_1 = QHBoxLayout()
        horizontal_toolbar_1.addWidget(self.btn7)
        horizontal_toolbar_1.addWidget(self.btn10)
        horizontal_toolbar_1.addWidget(toolbar_1)
        self.tab1 = QWidget()
        self.tab2 = QWidget()
        self.tab3 = QWidget()
        self.tab4 = QWidget()
        self.tabs.addTab(self.tab1, "Energy Matrix")
        self.tabs.addTab(self.tab2, "Energy distribution")
        self.tabs.addTab(self.tab3, "GC content distribution")
        self.tabs.addTab(self.tab4, "Energy ratio distribution")

        self.tab1.layout = QVBoxLayout()
        self.tab1.layout.addWidget(self.canvas)
        self.tab1.layout.addLayout(horizontal_toolbar_1)
        self.tab1.setLayout(self.tab1.layout)
        self.canvas.mpl_connect("button_press_event", self.render_structure)

        self.distribution = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.distribution.setFixedSize(490, 500)

        toolbar_2 = NavigationToolbar2QT(self.distribution, self)
        horizontal_toolbar_2 = QHBoxLayout()
        horizontal_toolbar_2.addWidget(toolbar_2)
        self.tab2.layout = QVBoxLayout()
        self.tab2.layout.addWidget(self.distribution)
        self.tab2.layout.addLayout(horizontal_toolbar_2)
        self.tab2.setLayout(self.tab2.layout)

        self.distribution_gc = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.distribution_gc.setFixedSize(490, 500)

        toolbar_3 = NavigationToolbar2QT(self.distribution_gc, self)
        horizontal_toolbar_3 = QHBoxLayout()
        horizontal_toolbar_3.addWidget(toolbar_3)

        self.tab3.layout = QVBoxLayout()
        self.tab3.layout.addWidget(self.distribution_gc)
        self.tab3.layout.addLayout(horizontal_toolbar_3)
        self.tab3.setLayout(self.tab3.layout)

        self.distribution_ratio = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.distribution_ratio.setFixedSize(490, 500)

        toolbar_4 = NavigationToolbar2QT(self.distribution_ratio, self)
        horizontal_toolbar_4 = QHBoxLayout()
        horizontal_toolbar_4.addWidget(toolbar_4)

        self.tab4.layout = QVBoxLayout()
        self.tab4.layout.addWidget(self.distribution_ratio)
        self.tab4.layout.addLayout(horizontal_toolbar_4)
        self.tab4.setLayout(self.tab4.layout)

        main_layout = QHBoxLayout()

        sub_bottom = QHBoxLayout()
        self.top_layout = QHBoxLayout()
        self.top_layout.setSpacing(30)
        self.center_layout = QFormLayout()
        self.bottom_layout = QHBoxLayout()
        self.bottom_layout.setSpacing(30)
        self.right_side = QVBoxLayout()
        self.left_side = QVBoxLayout()
        self.top_layout.addWidget(self.btn1)
        self.top_layout.addWidget(QLabel("GC content range:"))
        self.top_layout.addWidget(self.gc_range_picker)
        self.bottom_layout.addWidget(self.btn9)
        self.bottom_layout.addWidget(self.btn8)
        self.bottom_layout.addWidget(self.btn3)
        export = QVBoxLayout()
        export.addWidget(self.btn4)
        self.bottom_layout.addLayout(export)
        self.bottom_layout.addWidget(self.btn5)
        self.left_side.addLayout(self.top_layout)

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self.center_layout)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)
        self.left_side.addWidget(self.scroll)
        self.left_side.addLayout(self.bottom_layout)

        self.right_side.addWidget(self.tabs)
        self.progress = QProgressBar()
        self.progress.setAlignment(Qt.AlignHCenter)
        self.progress.setFixedSize(350, 30)
        sub_bottom.addWidget(self.progress)

        self.right_side.addLayout(sub_bottom)
        main_layout.addLayout(self.left_side)
        main_layout.addLayout(self.right_side)
        self.setLayout(main_layout)
        self.setWindowTitle("DNA origami")
        self.move(100, 100)
        self.setFixedSize(1200, 700)
        self.show()

    def input(self):
        input_widget = Structure_viewer(self)
        input_widget.input()

    def user_input(self):
        """
        This function is used to take the user input and send it to render_form() to create the form layout for the input provided.

        Args:
                self.raw_structure : The raw input as inputed by the user from user_input()
        """
        while self.center_layout.count() != 0:
            self.center_layout.removeRow(0)

        (
            self.header,
            self.field,
            self.label,
            self.check,
            self.regions,
            self.strand,
            self.energy,
            self.population_size,
        ) = ([], [], [], [], [], [], [], [])

        self.fixed_regions, self.input_sequence = {}, {}

        try:
            self.render_form()
        except (KeyError, IndexError):
            error = QErrorMessage(self)
            error.showMessage("Please follow the given structure format")
            while self.center_layout.count() != 0:
                self.center_layout.removeRow(0)

            (
                self.header,
                self.field,
                self.label,
                self.check,
                self.regions,
                self.strand,
                self.energy,
                self.population_size,
            ) = ([], [], [], [], [], [], [], [])

            self.fixed_regions, self.input_sequence = {}, {}
            self.raw_structure = None

    def render_form(self):
        """
        This function is used to process the input provided by the user and render a form layout containing a header as the region identifier,
        the population size, its GC content, a random sequence generated for this region identifier and a checkbox if this region can be modified.

        Args:
                self.regions : Regions by the user in user_input()
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.input_sequences : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
        """
        self.regions, self.header = [], []

        structure = [
            [
                Region(
                    re.findall("\D+", region)[0],
                    int(re.findall("\d+", region)[0]),
                )
                for region in strand
            ]
            for strand in [
                strand.strip().split() for strand in self.raw_structure.split(",")
            ]
        ]

        population_size = []
        for _, struct in enumerate(structure):
            region = ""
            for j in range(len(struct)):
                if not str(struct[j]).split("'")[1] in self.header:
                    self.header.append(str(struct[j]).split("'")[1])
                    population_size.append(
                        int(str(struct[j]).split(" ")[1].split(")")[0])
                    )

                if j == 0:
                    region += str(struct[j]).split("'")[1]
                else:
                    region += "--" + str(struct[j]).split("'")[1]
            self.regions.append(region)

        self.population_size = population_size

        sequence = Sequence.random_sequence(structure, self.fixed_regions)
        self.strand = [
            sequence.build_strand(strand) for strand in sequence.strand_structures
        ]

        if self.input_sequence != {}:
            bases = ""
            for i, region in enumerate(self.regions):
                for _ in region.split("--"):
                    bases += str(self.input_sequence[_])

                self.strand[i].bases = bases
                bases = ""

        for _ in range(len(self.strand)):
            bases = self.strand[_].bases
            while bases.find("AAAAAA") != -1:
                index = bases.index("AAAAAA")
                bases = bases[:index] + "T" + bases[index + 1 :]
            while bases.find("TTTTTT") != -1:
                index = bases.index("TTTTTT")
                bases = bases[:index] + "A" + bases[index + 1 :]
            while bases.find("CCCCCC") != -1:
                index = bases.index("CCCCCC")
                bases = bases[:index] + "G" + bases[index + 1 :]
            while bases.find("GGGGGG") != -1:
                index = bases.index("GGGGGG")
                bases = bases[:index] + "C" + bases[index + 1 :]
            self.strand[_].bases = bases

        data = gc_content(self)

        for header in self.header:
            self.label.append(
                QLabel(
                    header
                    + str(len(data[header]["bases"]))
                    + " (GC count: "
                    + str(data[header]["gc"])
                    + ") "
                )
            )
            self.label[-1].setFixedSize(170, 30)
            self.check.append(QCheckBox("Set as fixed region"))

            if header.islower():
                if header in self.fixed_regions.keys():
                    self.field.append(QLineEdit(data[header]["bases"]))
                    self.check[-1].setChecked(True)
                    self.field[-1].setEnabled(False)
                    self.field[-1].setMaxLength(len(data[header]["bases"]))
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[-1].setValidator(validator)
                    row = QHBoxLayout()
                    row.addWidget(self.field[-1])
                    row.addWidget(self.check[-1])
                else:
                    self.field.append(QLineEdit(data[header]["bases"]))
                    self.field[-1].setMaxLength(len(data[header]["bases"]))
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[-1].setValidator(validator)
                    row = QHBoxLayout()
                    row.addWidget(self.field[-1])
                    row.addWidget(self.check[-1])
            else:
                self.field.append(QLineEdit(data[header]["bases"]))
                self.field[-1].setEnabled(False)
                row = QHBoxLayout()
                row.addWidget(self.field[-1])

            self.field[-1].setFixedSize(300, 30)
            self.center_layout.addRow(self.label[-1], row)
            self.field[-1].editingFinished.connect(self.strand_update)
            self.check[-1].stateChanged.connect(self.set_fixed)

    def strand_update(self):
        """
        This function is used to fire after the user updates a sequence in the user fields and performs the modifications in the strand variable.

        Args:
                self.field : Fields generated by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
                self.label : A text box containing a region identifier with its respective gc content
        """
        data = gc_content(self)
        for _, field in enumerate(self.field):
            field.setStyleSheet("background-color: white")
            if field.isModified():
                text = field.text()

                if len(text) != len(data[self.header[_]]["bases"]):
                    field.setText(data[self.header[_]]["bases"])

                else:
                    uppercase_text = text.upper()
                    complemented_base = complement(uppercase_text)

                    if self.header[_].islower():
                        for i in range(len(self.strand)):
                            if (
                                data[self.header[_].lower()]["bases"]
                                in self.strand[i].bases
                            ):
                                old_base = self.strand[i].bases
                                updated_base = old_base.replace(
                                    data[self.header[_]]["bases"], text
                                )
                                self.strand[i].bases = updated_base

                            if self.header[_].upper() in data.keys():
                                if (
                                    data[self.header[_].upper()]["bases"]
                                    in self.strand[i].bases
                                ):
                                    old_base = self.strand[i].bases
                                    updated_base = old_base.replace(
                                        data[self.header[_].upper()]["bases"],
                                        complemented_base,
                                    )
                                    self.strand[i].bases = updated_base

                    if self.header[_].isupper():
                        for j in range(len(self.strand)):
                            if (
                                data[self.header[_].lower()]["bases"]
                                in self.strand[j].bases
                            ):
                                old_base = self.strand[j].bases
                                updated_base = old_base.replace(
                                    data[self.header[_].lower()]["bases"],
                                    complemented_base,
                                )
                                self.strand[j].bases = updated_base

                            if self.header[_].upper() in data.keys():
                                if (
                                    data[self.header[_].upper()]["bases"]
                                    in self.strand[j].bases
                                ):
                                    old_base = self.strand[j].bases
                                    updated_base = old_base.replace(
                                        data[self.header[_].upper()]["bases"], text
                                    )
                                    self.strand[j].bases = updated_base

                    updated_data = gc_content(self)
                    self.label[_].setText(
                        self.header[_]
                        + str(len(updated_data[self.header[_]]["bases"]))
                        + " (GC count: "
                        + str(updated_data[self.header[_]]["gc"])
                        + ") "
                    )

                    for region_identifier, base in updated_data.items():
                        if base["bases"] != data[region_identifier]["bases"]:
                            for index, header in enumerate(self.header):
                                if region_identifier == header:
                                    self.label[index].setText(
                                        region_identifier
                                        + str(
                                            len(updated_data[self.header[_]]["bases"])
                                        )
                                        + " (GC count: "
                                        + str(updated_data[self.header[_]]["gc"])
                                        + ") "
                                    )
                                    self.field[index].setText(base["bases"])

    def set_fixed(self):
        """
        This function is used to define fixed regions by the user and store them in a dictionary variable.

        Args:
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
        """
        self.fixed_regions = {}
        for _, check in enumerate(self.check):
            if check.isChecked() == True:
                self.field[_].setEnabled(False)
                data = gc_content(self)
                self.fixed_regions[self.header[_]] = data[self.header[_]]["bases"]
                self.fixed_regions[self.header[_].upper()] = data[
                    self.header[_].upper()
                ]["bases"]
            if check.isChecked() == False:
                if self.header[_].islower():
                    self.field[_].setEnabled(True)

    def user_max(self):
        """
        This function is used to specify the max value that is shown in the heatmap and is defined by the user with a validation step.

        Args:
                self.max : A value set by the user to rescale the heatmap max value
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        energy = QInputDialog()
        text, reply = energy.getText(
            self,
            "Maximum Energy",
            "Enter the maximum energy value for this energy matrix:",
        )
        if reply:
            if str(text) != "":
                if float(text) >= 0:
                    self.max = float(text)
                    if self.energy != 0:
                        minimum = [min(self.energy[_]) for _ in range(len(self.energy))]

                        if self.max > min(minimum):
                            self.update()
                        else:
                            error = QErrorMessage(self)
                            error.showMessage(
                                "This value is less than the minimum possible value"
                            )
                            self.max = 0

                else:
                    error = QErrorMessage(self)
                    error.showMessage("Please give a positive value")

    def export(self):
        """
        This function is used to export the current configuration and respects the upload format required by the application.

        Args:
                self.regions : Regions provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
        """
        if self.strand != []:
            window = Export_message(self)
            window.export()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a configuration")

    def load(self):
        """
        This function is responsable for the upload fonctionality of the application and takes in a ".dat" file structured as the export format defined.

        Args:
                self.header : Region identifiers provided by the user in user_input()
                self.field : Fields generated by the user in user_input()
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.regions : Regions provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.population_size : Length of a given region provided by the user in user_input()
                self.input_sequence : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        filename = QFileDialog.getOpenFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if not filename[0].endswith(".dat"):
                error = QErrorMessage(self)
                error.showMessage("Please upload a file with .dat extension")
            else:
                try:
                    while self.center_layout.count() != 0:
                        self.center_layout.removeRow(0)

                    (
                        self.header,
                        self.field,
                        self.label,
                        self.check,
                        self.regions,
                        self.highlighted,
                        self.index,
                        self.strand,
                        self.population_size,
                    ) = ([], [], [], [], [], [], [], [], [])
                    self.fixed_regions = {}
                    self.input_sequence = {}
                    with open(filename[0], "r") as configfile:
                        params = yaml.load(configfile, Loader=yaml.FullLoader)
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions = params["fixed_regions"]
                        self.input_sequence = params["input_sequence_definitions"]
                        self.render_form()
                        self.update()

                except FileNotFoundError:
                    pass
                except TypeError:
                    error = QErrorMessage(self)
                    error.showMessage("Please upload a file with .dat extension")
                except KeyError:
                    error = QErrorMessage(self)
                    error.showMessage("Please respect the configuration file format")

    def _on_gc_range_changed(self):
        # print(self.gc_range_picker.value())
        self.gc_min, self.gc_max = self.gc_range_picker.value()
        self.gc_min, self.gc_max = self.gc_min / 100, self.gc_max / 100
        # print(self.gc_min, self.gc_max)
        # print("here!!!!!!!!")
        self.gc_range_changed = True
        while True:
            if not self.gc_range_handler():
                break

    def gc_range_handler(self) -> bool:
        # print("heri")
        flag = False
        if self.strand != []:
            data = gc_content(self)
            # print("hero")

            for index, header in enumerate(self.header):
                # print(data[header]["gc"] / len(data[header]["bases"]))
                if data[header]["gc"] / len(data[header]["bases"]) < self.gc_min:
                    if self.header[index].islower():
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("A", "G", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("T", "G", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        flag = True

                    else:
                        for j, head in enumerate(self.header):
                            if head.islower():
                                if head == self.header[index].lower():
                                    index = j
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("A", "G", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("T", "G", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        flag = True

                if data[header]["gc"] / len(data[header]["bases"]) > self.gc_max:
                    if self.header[index].islower():
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("G", "A", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("C", "A", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        flag = True

                    else:
                        for j, head in enumerate(self.header):
                            if head.islower():
                                if head == self.header[index].lower():
                                    index = j
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("G", "A", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("C", "A", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        flag = True

            return flag

    def calculate(self):
        """
        This function is responsable for the call to Mfold software and stores the returned energy in a matrix variable.
        It also makes sure that the gc content boundaries are respected.

        Args:
                self.strand : Structure class used to define the strand sequences
                self.header : Region identifiers provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.field : Fields generated by the user in user_input()
        """
        self.btn3.setEnabled(False)

        self._on_gc_range_changed()

        if self.strand == []:
            error = QErrorMessage(self)
            error.showMessage("Please provide a structure")
            self.btn3.setEnabled(True)

        else:
            for field in self.field:
                field.setToolTip("")

            try:
                self.run_calculation()
                process_mfold_files(self)
                self.highlight_thief()
                clear_files()
                self.update()
                if not self.automate:
                    self.progress.setFormat("DONE")
                self.btn3.setEnabled(True)
                self.gc_range_changed = False
            except StopIteration:
                error = QErrorMessage(self)
                message = list(self.fixed_regions.keys())
                message = [x for x in message if x.islower()]
                message = ", ".join(message)
                error.showMessage(
                    f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                )
                self.progress.setFormat("An error occured")
                self.progress.setValue(100)
                clear_files()
                self.btn3.setEnabled(True)
                self.automate = True

    def run_calculation(self):
        """
        This function initiates the call to the mfold software and populates the energy matrix of the main class while updating the progress.

        Args:
                self.progress : Progress bar variable for live update on the main widget
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.strand : Structure class used to define the strand sequences
                self.region : Regions provided by the user in user_input()

        """
        if not self.automate:
            self.progress.setFormat("PROGRESSING")
        self.energy = [[None for strand1 in self.strand] for strand2 in self.strand]
        self.stability = [[None for strand1 in self.strand] for strand2 in self.strand]

        for i in range(len(self.strand)):
            if not self.automate:
                self.progress.setValue(int((i / len(self.strand)) * 100))
            for j in range(len(self.strand)):
                self.retrieve_ct(i, j)

        if not self.automate:
            self.progress.setValue(100)

    def retrieve_ct(self, i, j):
        """
        This function isolates the call to the mfold software for different functions in the class.

        Args:
                self.strand : Structure class used to define the strand sequences
                self.region : Regions provided by the user in user_input()

        """
        mfold = Mfold(output_folder=f"./", mfold_command="mfold_quik")
        run = mfold.run

        region1 = self.regions[i].split("--")
        region2 = self.regions[j].swapcase().split("--")
        region2 = region2[::-1]

        run(
            self.strand[i],
            self.strand[j],
            set_constraints(self, region1, region2),
            f"{i}_{j}.seq",
            f"{i}_{j}.aux",
        )
        with open(f"{i}_{j}.det", "r") as configfile:
            for line in configfile:
                if line.startswith(" dG = "):
                    self.energy[i][j] = abs(float(line[9:15]))
                    break

        # Calculate the stability matrix
        first_strand = Strand(self.strand[i].bases + self.strand[j].bases, [])
        second_strand = Strand(
            complement(self.strand[j].bases) + complement(self.strand[i].bases), []
        )

        run(
            first_strand,
            second_strand,
            None,
            f"{i}_{j}_{i}.seq",
            f"{i}_{j}_{i}.aux",
        )
        with open(f"{i}_{j}_{i}.det", "r") as configfile:
            for line in configfile:
                if line.startswith(" dG = "):
                    self.stability[i][j] = self.energy[i][j] / abs(float(line[9:15]))
                    break

    def figure_generation(self):
        """
        This function is responsable for the structure viewer generated images.

        Args:
                self.shape : Indices to identify the interaction to be generated
                self.strand : Structure class used to define the strand sequences
                self.regions : Regions provided by the user in user_input()
        """
        for e in self.shape:
            shape = e.replace(".png", "").split("_")
            shape = [int(i) for i in shape]

            with open(f"{shape[0]}_{shape[1]}.ct", "r") as configfile:
                nodes_list = []
                G = nx.MultiDiGraph()

                labels = {}
                counter = 0
                before = 0
                center = 0
                extra = 0
                for line in configfile:
                    if line[7:8] == "d":
                        exit = int(line[3:6])
                        continue

                    if line[7:8] == "L":
                        continue

                    if counter < len(self.strand[shape[0]].bases):
                        before = int(line[12:15])
                        center = int(line[3:6])
                        nodes_list.append(before)
                        G.add_edge(before, center, color="black", weight=100)

                        if counter == 1:
                            G.add_node(
                                f"{self.regions[shape[0]]}:{counter}",
                                weight=f"{self.regions[shape[0]]}:{counter}",
                            )
                            labels[f"{self.regions[shape[0]]}:{counter}"] = f"{counter}"
                            G.add_edge(
                                f"{self.regions[shape[0]]}:{counter}",
                                0,
                                color="black",
                                weight=100,
                            )

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[shape[0]]}:{counter+1}",
                                weight=f"{self.regions[shape[0]]}:{counter+1}",
                            )
                            labels[
                                f"{self.regions[shape[0]]}:{counter+1}"
                            ] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[shape[0]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if int(line[26:30]) != 0:
                            if int(line[26:30]) < len(self.strand[shape[0]].bases):
                                extra = int(line[26:30]) - 1

                            if int(line[26:30]) > len(self.strand[shape[0]].bases):
                                extra = int(line[26:30]) - 4

                            if extra != 0:
                                # print(
                                #     before,
                                #     extra,
                                #     self.thief.loc["index_app", f"{shape[0]}{shape[1]}"]
                                #     - 1,
                                #     self.thief.loc["end", f"{shape[0]}{shape[1]}"],
                                # )
                                if (
                                    self.thief.loc["index_app", f"{shape[0]}{shape[1]}"]
                                    - 1
                                    <= extra
                                    and extra
                                    < self.thief.loc["end", f"{shape[0]}{shape[1]}"]
                                ):
                                    G.add_edge(before, extra, color="red", weight=200)
                                    if extra == 1:
                                        G.add_edge(
                                            before + 1,
                                            extra - 1,
                                            color="red",
                                            weight=200,
                                        )
                                else:
                                    if not G.has_edge(extra, before):
                                        G.add_edge(
                                            before, extra, color="black", weight=200
                                        )

                        counter += 1
                        extra = 0

                    else:
                        before = int(line[12:15]) - 3
                        center = int(line[3:6]) - 3
                        extra = 0

                        nodes_list.append(before)

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[shape[1]]}:{counter+1}",
                                weight=f"{self.regions[shape[1]]}:{counter+1}",
                            )
                            labels[
                                f"{self.regions[shape[1]]}:{counter+1}"
                            ] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[shape[1]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if exit == int(line[3:6]):
                            if line[7:8] == "d":
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break
                            else:
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break

                        G.add_edge(before, center, color="black", weight=100)

                        if int(line[26:30]) != 0:
                            if int(line[26:30]) <= len(self.strand[shape[0]].bases):
                                extra = int(int(line[26:30]) - 1)

                            if int(line[26:30]) > len(self.strand[shape[0]].bases):
                                extra = int(int(line[26:30]) - 4)

                            if extra != 0:
                                # print(
                                #     before,
                                #     extra,
                                #     self.thief.loc["index_app", f"{shape[0]}{shape[1]}"]
                                #     - 1,
                                #     self.thief.loc["end", f"{shape[0]}{shape[1]}"],
                                # )
                                if (
                                    self.thief.loc["index_app", f"{shape[0]}{shape[1]}"]
                                    - 1
                                    <= extra
                                    and extra
                                    < self.thief.loc["end", f"{shape[0]}{shape[1]}"]
                                ):
                                    G.add_edge(before, extra, color="red", weight=200)
                                else:
                                    if not G.has_edge(extra, before):
                                        G.add_edge(
                                            before, extra, color="black", weight=200
                                        )

                        counter += 1

                sequence = self.strand[shape[0]].bases + self.strand[shape[1]].bases

                for _, t in enumerate(sequence):
                    G.add_node(nodes_list[_], weight=t)
                    labels[_] = G.nodes[_]["weight"]

                options = {
                    "linewidths": 2,
                    "alpha": 0.8,
                    "node_color": "white",
                    "width": 2,
                    "arrowstyle": "-",
                    "arrowsize": 2,
                    "node_size": 90,
                    "font_size": 8,
                }

                colors = nx.get_edge_attributes(G, "color").values()

                pos = nx.kamada_kawai_layout(G, weight="weight")

                nx.draw(
                    G,
                    pos=pos,
                    with_labels=True,
                    labels=labels,
                    edge_color=colors,
                    **options,
                )

                plt.savefig(e, dpi=300)
                plt.clf()
                plt.close()

        current_dir = os.getcwd()
        files = os.listdir(current_dir)

        for item in files:
            if item.endswith(f".png"):
                if not item in self.shape:
                    os.remove(os.path.join(current_dir, item))

        self.shape = []

    def highlight_thief(self):
        """
        This function is used to highlighted the fields responsable for the energy loss binding the different strands.

        Args:
                self.highlighted : a list of sequences that are responsable for the energy loss found in highlight_thief()
                self.index : a list of indices corresponding to the sequences in self.highlighted
        """
        self.highlighted, self.index, self.shape = [], [], []
        NUMBER_OF_MODIFICATIONS = 2

        for _ in range(len(self.field)):
            self.field[_].setToolTip("")
            self.field[_].setStyleSheet("background-color:white")

        saved_data = self.thief
        while len(self.shape) < NUMBER_OF_MODIFICATIONS:
            highlighted, indices = manipulate_highlights(self)
            self.highlighted += highlighted
            self.index += indices
        self.thief = saved_data

        if not self.automate:
            for e in self.shape:
                shape = e.replace(".png", "").split("_")
                shape = [int(i) for i in shape]

                try:
                    open(f"{shape[0]}_{shape[1]}.ct", "r")
                except FileNotFoundError:
                    self.retrieve_ct(shape[0], shape[1])

            self.figure_generation()

        counter = 0
        while counter < len(self.highlighted):
            if self.header[self.index[counter]].isupper():
                complemented = complement(self.highlighted[counter])

                complemented = (
                    complemented.replace("]", "temp")
                    .replace("[", "]")
                    .replace("temp", "[")
                )

                self.highlighted[counter] = complemented
                index = self.header.index(self.header[self.index[counter]].lower())
                self.index[counter] = index

            counter += 1

        for d in range(len(self.index)):
            text = self.field[self.index[d]].toolTip()
            if text != "":
                if text != self.highlighted[d]:
                    self.field[self.index[d]].setToolTip(
                        text + "\n" + self.highlighted[d] + "\n"
                    )
            else:
                self.field[self.index[d]].setToolTip(self.highlighted[d])
            self.field[self.index[d]].setStyleSheet("background-color:red")

    def render_structure(self, event):
        """
        This function is responsable for the event handling during a click on a square in the heatmap figure
        """
        self.new_widget = Paint_structure(self)
        try:
            x = int(np.round(event.xdata))
            y = int(np.round(event.ydata))
            self.new_widget.paint(x, y)
        except TypeError:
            pass

    def randomize_strand(self):
        """
        This function is used to automatically correct the energy loss found in run_calculate().

        Args:
                self.automate : a flag used to bypass loop_calculation()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                    and associated sequence as item
        """

        try:
            self.automate = True
            if self.gc_range_changed:
                self.progress.setFormat("Adjusting gc content range")
                self.progress.setValue(0)
                self.run_calculation()
                process_mfold_files(self)
                self.highlight_thief()
                clear_files()

            self.run_randomization()
        except StopIteration:
            error = QErrorMessage(self)
            message = list(self.fixed_regions.keys())
            message = [x for x in message if x.islower()]
            message = ", ".join(message)
            error.showMessage(
                f"Please make sure to uncheck some of these fields: {message} to allow modifications"
            )
            self.progress.setFormat("An error occured")
            self.progress.setValue(100)
            self.update()
            clear_files()
            self.btn3.setEnabled(True)
            self.btn8.setEnabled(True)
            self.automate = False

    def run_randomization(self):
        """
        This function is called to run optimize the highlighted strand and allows up to 5 tries in the case of failed optimizations or restore the current configuration for further tries.
        """
        LIMIT_OF_TRIES = 5

        if self.highlighted == []:
            error = QErrorMessage(self)
            error.showMessage(
                "Please run the calculation once again to highlight regions"
            )

        else:
            self.btn8.setEnabled(False)
            self.progress.setFormat("Randomizing")
            tries = 0

            params = {}
            data = gc_content(self)
            self.input_sequence = {
                self.header[_]: data[self.header[_]]["bases"]
                for _ in range(len(self.header))
            }

            params["raw_structure"] = self.raw_structure
            params["energy_matrix"] = self.energy
            params["fixed_regions"] = self.fixed_regions
            params["input_sequence_definitions"] = self.input_sequence
            params["highlighted"] = self.highlighted
            params["index"] = self.index
            params["shape"] = self.shape
            params["stability"] = self.stability
            params["thief"] = self.thief.to_dict()

            saved = json.dumps(params)

            self.progress.setValue(int((tries / LIMIT_OF_TRIES) * 100))
            self.automate = False
            for iteration in range(LIMIT_OF_TRIES):
                (
                    new_maximum,
                    current_max,
                ) = self.randomize_validate_randomization()
                if new_maximum < current_max:
                    break
                else:
                    while self.center_layout.count() != 0:
                        self.center_layout.removeRow(0)

                    (
                        self.header,
                        self.field,
                        self.label,
                        self.check,
                        self.index,
                        self.highlighted,
                        self.shape,
                        self.energy,
                        self.stability,
                        self.raw_structure,
                        self.thief,
                    ) = ([], [], [], [], [], [], [], [], [], None, None)
                    self.input_sequence, self.fixed_regions = {}, {}

                    params = json.loads(saved)
                    self.raw_structure = params["raw_structure"]
                    self.energy = params["energy_matrix"]
                    self.fixed_regions.update(params["fixed_regions"])
                    self.input_sequence.update(params["input_sequence_definitions"])
                    self.index = params["index"]
                    self.highlighted = params["highlighted"]
                    self.shape = params["shape"]
                    self.stability = params["stability"]
                    self.thief = pd.DataFrame.from_dict(params["thief"])

                    self.render_form()
                    tries += 1
                    if not self.automate:
                        self.progress.setValue(int((tries / LIMIT_OF_TRIES) * 100))

            if new_maximum > current_max:
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)
                (
                    self.header,
                    self.field,
                    self.label,
                    self.check,
                    self.index,
                    self.highlighted,
                    self.shape,
                    self.energy,
                    self.raw_structure,
                    self.thief,
                    self.stability,
                ) = ([], [], [], [], [], [], [], [], None, None, [])
                self.input_sequence, self.fixed_regions = {}, {}

                params = json.loads(saved)
                self.raw_structure = params["raw_structure"]
                self.energy = params["energy_matrix"]
                self.stability = params["stability"]
                self.fixed_regions.update(params["fixed_regions"])
                self.input_sequence.update(params["input_sequence_definitions"])
                self.index = params["index"]
                self.highlighted = params["highlighted"]
                self.shape = params["shape"]
                self.stability = params["stability"]
                self.thief = pd.DataFrame.from_dict(params["thief"])

                self.render_form()

            self.progress.setFormat("Generating structures")
            self.progress.setValue(100)
            self.automate = True

            self.automate = False
            process_mfold_files(self)
            self.highlight_thief()
            self.update()

            self.progress.setFormat("DONE")
            self.btn3.setEnabled(True)
            self.btn8.setEnabled(True)
            clear_files()

    def randomize_validate_randomization(self):
        """
        This function computes the current highest energy value, makes a random optimization and computes the resulting highest energy value.
        """
        higher = 0
        for i in range(len(self.stability)):
            for j in range(len(self.stability)):
                if self.stability[i][j] != None:
                    if self.stability[i][j] > higher:
                        higher = self.stability[i][j]

        current_max = higher

        flag = False
        counter = 0
        while counter < len(self.highlighted):
            fields = []

            for a, highlight in enumerate(self.highlighted):
                text = ""

                for b in highlight:
                    if b == "]":
                        flag = False

                    elif flag:
                        text += random.choice(["G", "T", "C", "A"])

                    elif b == "[":
                        flag = True

                    else:
                        text += b

                while text.find("AAAAAA") != -1:
                    index = text.index("AAAAAA")
                    text = text[:index] + "T" + text[index + 1 :]
                while text.find("TTTTTT") != -1:
                    index = text.index("TTTTTT")
                    text = text[:index] + "A" + text[index + 1 :]
                while text.find("CCCCCC") != -1:
                    index = text.index("CCCCCC")
                    text = text[:index] + "G" + text[index + 1 :]
                while text.find("GGGGGG") != -1:
                    index = text.index("GGGGGG")
                    text = text[:index] + "C" + text[index + 1 :]

                fields.append(text)

            gci = 0
            for _ in fields[counter]:
                gci += _.count("G")
                gci += _.count("C")

            if (gci / self.population_size[self.index[counter]]) < self.gc_min or (
                gci / self.population_size[self.index[counter]]
            ) > self.gc_max:
                if "]" in self.highlighted[counter]:
                    flag = False

                if (
                    "[" in self.highlighted[counter]
                    and not "]" in self.highlighted[counter]
                ):
                    flag = True
                continue

            else:
                if self.index.count(self.index[counter]) > 1:
                    indices = [
                        i for i, x in enumerate(self.index) if x == self.index[counter]
                    ]
                    indices.pop(0)

                    for i in indices:
                        complemented = self.highlighted[i]

                        new_indices_o = [
                            j
                            for j in range(len(complemented))
                            if complemented.startswith("[", j)
                        ]

                        new_indices_c = [
                            j
                            for j in range(len(complemented))
                            if complemented.startswith("]", j)
                        ]
                        complemented = [c for c in fields[counter]]
                        for k in new_indices_o:
                            complemented.insert(k, "[")

                        for l in new_indices_c:
                            complemented.insert(l, "]")

                        complemented = "".join(complemented)
                        self.highlighted[i] = complemented

                for i in range(len(self.header)):
                    if self.header[self.index[counter]].islower():
                        if self.header[i] == self.header[self.index[counter]].upper():
                            indices = [j for j, x in enumerate(self.index) if x == i]
                            for k in indices:
                                complemented = self.highlighted[k]
                                new_indices_o = [
                                    j
                                    for j in range(len(complemented))
                                    if complemented.startswith("[", j)
                                ]

                                new_indices_c = [
                                    j
                                    for j in range(len(complemented))
                                    if complemented.startswith("]", j)
                                ]
                                complemented = complement(fields[counter])

                                complemented = [c for c in complemented]
                                for l in new_indices_o:
                                    complemented.insert(l, "[")

                                for m in new_indices_c:
                                    complemented.insert(m, "]")

                                complemented = "".join(complemented)
                                self.highlighted[k] = complemented

                    if self.header[self.index[counter]].isupper():
                        if self.header[i] == self.header[self.index[counter]].lower():
                            indices = [j for j, x in enumerate(self.index) if x == i]
                            for k in indices:
                                complemented = self.highlighted[k]

                                new_indices_o = [
                                    j
                                    for j in range(len(complemented))
                                    if complemented.startswith("[", j)
                                ]

                                new_indices_c = [
                                    j
                                    for j in range(len(complemented))
                                    if complemented.startswith("]", j)
                                ]
                                complemented = complement(fields[counter])

                                complemented = [c for c in complemented]
                                for l in new_indices_o:
                                    complemented.insert(l, "[")
                                for m in new_indices_c:
                                    complemented.insert(m, "]")

                                complemented = "".join(complemented)

                                self.highlighted[k] = complemented

                self.field[self.index[counter]].setText(fields[counter])
                self.field[self.index[counter]].setModified(True)
                self.strand_update()

                try:
                    if "]" in self.highlighted[counter]:
                        if "[" in self.highlighted[counter]:
                            counter += 1
                            continue
                        flag = True
                except IndexError:
                    pass

                counter += 1

        if not self.automate:
            self.progress.setFormat("Testing randomization")

        headers = [self.header[_] for _ in self.index]

        for i in range(len(self.strand)):
            for j in range(len(self.strand)):
                if (
                    any(
                        map(lambda value: value in self.regions[i].split("--"), headers)
                    )
                    or any(
                        map(
                            lambda value: value
                            in self.regions[i].swapcase().split("--"),
                            headers,
                        )
                    )
                    or any(
                        map(lambda value: value in self.regions[j].split("--"), headers)
                    )
                    or any(
                        map(
                            lambda value: value
                            in self.regions[j].swapcase().split("--"),
                            headers,
                        )
                    )
                ):

                    self.retrieve_ct(i, j)

                    data = {}
                    data[f"{i}{j}"] = {}
                    parse_ct_file(self, data, i, j)

                    self.thief.loc["energy", f"{i}{j}"] = self.energy[i][j]
                    self.thief.loc["letter", f"{i}{j}"] = data[f"{i}{j}"]["letter"]
                    self.thief.loc["max", f"{i}{j}"] = data[f"{i}{j}"]["max"]
                    self.thief.loc["index_app", f"{i}{j}"] = data[f"{i}{j}"][
                        "index_app"
                    ]
                    self.thief.loc["end", f"{i}{j}"] = data[f"{i}{j}"]["end"]
                    self.thief.loc["shape", f"{i}{j}"] = f"{i}_{j}.png"

        higher = 0
        for i in range(len(self.stability)):
            for j in range(len(self.stability)):
                if self.stability[i][j] != None:
                    if self.stability[i][j] > higher:
                        higher = self.stability[i][j]

        new_max = higher

        return new_max, current_max

    def loop_calculation(self):
        """
        This function is used to start a widget to help the user specify the number of iterations and gc content range during the loop calculation/randomization process

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
        """
        loop_widget = QInputDialog()
        text, reply = loop_widget.getText(
            self,
            "Iterative optimizer",
            "Enter the number of iterations for the optimization of this configuration:",
        )
        if reply:
            if str(text) != "":
                try:
                    self.iterator = int(text)
                    if self.iterator <= 0:
                        raise ValueError

                    else:
                        self.automate = True
                        self.run_loop()

                except ValueError:
                    error = QErrorMessage(self)
                    error.showMessage(
                        f"Please make sure to provide an integer value greater than 0"
                    )
                    self.iterator = 0

    def run_loop(self):
        """
        This function is used to create iteration in the process of lowering energy loss by create loops of calculation and randomization.

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
                self.counter : a counter for the current iteration in loop_calculation()
                self.progress : a progressbar component used in the main layout
                self.field : Fields generated by the user in user_input()
        """
        try:
            LIMIT_OF_TRIES = 5
            if self.field == []:
                error = QErrorMessage(self)
                error.showMessage(f"Please make sure to provide a structure")

            else:
                self.btn9.setEnabled(False)
                self.btn3.setEnabled(False)
                self.btn8.setEnabled(False)

                self.automate = True
                tries = 0

                self.progress.setFormat("Optimizing")
                for count in range(self.iterator):
                    self.progress.setValue(int((self.counter / self.iterator) * 100))

                    if count == 0:
                        self.calculate()

                    self.automate = True

                    params = {}
                    data = gc_content(self)
                    self.input_sequence = {
                        self.header[_]: data[self.header[_]]["bases"]
                        for _ in range(len(self.header))
                    }

                    params["raw_structure"] = self.raw_structure
                    params["energy_matrix"] = self.energy
                    params["stability"] = self.stability
                    params["fixed_regions"] = self.fixed_regions
                    params["input_sequence_definitions"] = self.input_sequence
                    params["highlighted"] = self.highlighted
                    params["index"] = self.index
                    params["shape"] = self.shape
                    params["thief"] = self.thief.to_dict()

                    saved = json.dumps(params)

                    for iteration in range(LIMIT_OF_TRIES):
                        (
                            new_maximum,
                            current_max,
                        ) = self.randomize_validate_randomization()
                        if new_maximum < current_max:
                            break
                        else:
                            while self.center_layout.count() != 0:
                                self.center_layout.removeRow(0)

                            (
                                self.header,
                                self.field,
                                self.label,
                                self.check,
                                self.index,
                                self.highlighted,
                                self.shape,
                                self.energy,
                                self.raw_structure,
                                self.thief,
                            ) = ([], [], [], [], [], [], [], [], None, None)
                            self.input_sequence, self.fixed_regions = {}, {}

                            params = json.loads(saved)
                            self.raw_structure = params["raw_structure"]
                            self.energy = params["energy_matrix"]
                            self.fixed_regions.update(params["fixed_regions"])
                            self.input_sequence.update(
                                params["input_sequence_definitions"]
                            )
                            self.index = params["index"]
                            self.highlighted = params["highlighted"]
                            self.shape = params["shape"]
                            self.stability = params["stability"]
                            self.thief = pd.DataFrame.from_dict(params["thief"])

                            self.render_form()
                            tries += 1

                    if new_maximum > current_max:
                        while self.center_layout.count() != 0:
                            self.center_layout.removeRow(0)
                        (
                            self.header,
                            self.field,
                            self.label,
                            self.check,
                            self.index,
                            self.highlighted,
                            self.shape,
                            self.energy,
                            self.raw_structure,
                            self.thief,
                        ) = ([], [], [], [], [], [], [], [], None, None)
                        self.input_sequence, self.fixed_regions = {}, {}

                        params = json.loads(saved)
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions.update(params["fixed_regions"])
                        self.input_sequence.update(params["input_sequence_definitions"])
                        self.index = params["index"]
                        self.highlighted = params["highlighted"]
                        self.shape = params["shape"]
                        self.stability = params["stability"]
                        self.thief = pd.DataFrame.from_dict(params["thief"])

                        self.render_form()

                    self.highlight_thief()

                    self.counter += 1

                self.highlighted, self.index, self.shape = [], [], []

                self.progress.setFormat("Generating structures")
                self.progress.setValue(100)

                self.automate = False
                process_mfold_files(self)
                self.highlight_thief()
                self.update()
                self.progress.setFormat("DONE")

                self.counter = 0
                self.iterator = 0
                clear_files()
                self.btn9.setEnabled(True)
                self.btn8.setEnabled(True)
                self.btn3.setEnabled(True)

        except StopIteration:
            error = QErrorMessage(self)
            message = list(self.fixed_regions.keys())
            message = [x for x in message if x.islower()]
            message = ", ".join(message)
            error.showMessage(
                f"Please make sure to uncheck some of these fields: {message} to allow modifications"
            )
            self.progress.setFormat("An error occured")
            self.progress.setValue(100)
            self.update()
            clear_files()
            self.highlighted, self.index, self.shape = [], [], []

            self.automate = False
            self.counter = 0
            self.iterator = 0

            self.btn3.setEnabled(True)
            self.btn8.setEnabled(True)
            self.btn9.setEnabled(True)

    def output_data(self):
        """
        This function is used to export the heatmap energy matrix in a ".csv" file.

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region provided by the user in user_input()
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if self.energy == []:
                error = QErrorMessage(self)
                error.showMessage(f"There is no heatmap plot at the moment")
            else:
                try:
                    with open(filename[0] + ".csv", "w") as configfile:
                        columns = self.regions
                        df = pd.DataFrame(self.energy, columns=columns)
                        df.to_csv(configfile, index=False)
                except FileNotFoundError:
                    pass

    def update(self):
        """
        This function is used to generate the heatmap from the energy matrix found in calculate().

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region class used to define the regions defined
                self.canvas : A matplotlib figure class to draw the heatmap from the energy matrix stored in calculate()
                self.max : A value set by the user to rescale the heatmap max value
        """
        NUMBER_OF_MODIFICATIONS = 2
        if self.energy == []:
            error = QErrorMessage(self)
            error.showMessage(f"The energy matrix is empty!")

        else:
            self.canvas.figure.clear()
            self.distribution.figure.clear()
            self.distribution_gc.figure.clear()
            self.distribution_ratio.figure.clear()

            ax_matrix = self.canvas.figure.add_subplot(111)
            ax_dist = self.distribution.figure.add_subplot(111)
            ax_gc = self.distribution_gc.figure.add_subplot(111)
            ax_ratio = self.distribution_ratio.figure.add_subplot(111)

            ticks = self.regions
            if self.max != 0:
                try:
                    im = ax_matrix.imshow(
                        self.energy,
                        cmap="plasma",
                        interpolation="nearest",
                        vmax=self.max,
                    )
                except (TypeError, UnboundLocalError):
                    self.update()

            else:
                try:
                    im = ax_matrix.imshow(
                        self.energy, cmap="plasma", interpolation="nearest"
                    )
                except (TypeError, UnboundLocalError):
                    self.update()

            try:
                im_ratio = ax_ratio.imshow(
                    self.stability,
                    cmap="plasma",
                    interpolation="nearest",
                )

                ax_ratio.set_xticks(np.arange(len(ticks)))
                ax_ratio.set_yticks(np.arange(len(ticks)))
                ax_ratio.set_xticklabels(
                    ticks, fontsize=10, rotation=45, ha="right", linespacing=2
                )
                ax_ratio.set_yticklabels(ticks, fontsize=10)

                ax_ratio.figure.colorbar(
                    im_ratio,
                    orientation="vertical",
                )

                ax_ratio.format_coord = lambda x, y: f"Energy ratio"
            except (TypeError, UnboundLocalError):
                pass

            ax_matrix.set_xticks(np.arange(len(ticks)))
            ax_matrix.set_yticks(np.arange(len(ticks)))
            ax_matrix.set_xticklabels(
                ticks, fontsize=10, rotation=45, ha="right", linespacing=2
            )
            ax_matrix.set_yticklabels(ticks, fontsize=10)

            ax_matrix.figure.colorbar(
                im,
                label="Kcal/mol",
                orientation="vertical",
            )

            energy = [
                self.energy[i][j]
                for i in range(len(self.energy))
                for j in range(len(self.energy))
            ]

            gc = []
            gci = 0
            for i in range(len(self.strand)):
                gci += self.strand[i].bases.count("G")
                gci += self.strand[i].bases.count("C")
                gc.append(100 * gci / len(self.strand[i].bases))
                gci = 0

            df = pd.DataFrame(energy)
            df.plot(
                ax=ax_dist.axes,
                kind="hist",
                legend=False,
                xlabel="Energy",
                title=f"Energy distribution over {self.iterator} of iterations",
            )

            df = pd.DataFrame(gc)
            df.plot(
                ax=ax_gc.axes,
                kind="hist",
                legend=False,
                xlabel="GC content range",
                title=f"GC content distribution over {self.iterator} of iterations",
            )

            if self.thief is not None:
                try:
                    current_dir = os.getcwd()
                    files = os.listdir(current_dir)

                    to_highlight = {}
                    to_avoid = ""
                    for count in range(NUMBER_OF_MODIFICATIONS):
                        for file in files:
                            if file.endswith(".png"):
                                item = file.replace(".png", "")
                                i = int(item.split("_")[0])
                                j = int(item.split("_")[1])
                                if to_avoid != "":
                                    if i != int(to_avoid.split("-")[0]) or j != int(
                                        to_avoid.split("-")[1]
                                    ):
                                        to_highlight[count] = {"x": i, "y": j}
                                else:
                                    to_highlight[count] = {"x": i, "y": j}

                        to_avoid = (
                            str(to_highlight[count]["x"])
                            + "-"
                            + str(to_highlight[count]["y"])
                        )

                    for _ in range(len(to_highlight)):
                        ax_matrix.add_patch(
                            Rectangle(
                                (
                                    to_highlight[_]["y"] - 0.5,
                                    to_highlight[_]["x"] - 0.5,
                                ),
                                1,
                                1,
                                edgecolor="red",
                                fill=False,
                                lw=3,
                            )
                        )

                except KeyError:
                    pass

            ax_matrix.format_coord = lambda x, y: f"Energy"

            self.canvas.draw()
            self.distribution.draw()
            self.distribution_gc.draw()
            self.distribution_ratio.draw()

    def closeEvent(self, event):
        """
        This function is used to close/exit the main widget.
        """
        pop_message = QMessageBox()
        reply = pop_message.question(
            self,
            "Confirmation step",
            "Are you sure to quit?",
            QMessageBox.Yes | QMessageBox.No,
            0,
        )
        if reply == QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()


if __name__ == "__main__":
    window = QApplication(sys.argv)
    view = DNA_origami()
    sys.exit(window.exec_())
