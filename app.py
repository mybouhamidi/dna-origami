import faulthandler

import os
import random
import re
import sys

import yaml
from matplotlib.backends.backend_qt5 import NavigationToolbar2QT

faulthandler.enable()

# Import matplotlib for heatmap rendering
import networkx as nx
from matplotlib.patches import Rectangle

# Import QApplication and the required widgets from PyQt5.QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

# matplotlib.use("QT5Agg")
import matplotlib.pyplot as plt

# Import pandas and numpy for data manipulation
import numpy as np
import pandas as pd
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

from genetic import Sequence

# Import mfold required libraries
from mfold_library import Mfold, Region

NUMBER_OF_MODIFICATIONS = 2
LIMIT_OF_TRIALS = 5


def clear_files():
    """
    This function is called to clear the files generated by the Mfold software
    """
    extensions = [
        ".seq",
        ".ct",
        ".det",
        ".out",
        ".pnt",
        ".sav",
        ".test",
        ".log",
        ".cmd",
        ".aux",
        ".con",
    ]
    current_dir = os.getcwd()
    dir_items = os.listdir(current_dir)

    for item in dir_items:
        for extension in extensions:
            if item.endswith(extension):
                os.remove(os.path.join(current_dir, item))


def set_constraints(self, region1, region2):
    """
    This function is called to set constraints for the energy calculation generated by the Mfold software
    """
    data = gc_content([], self)
    constraint = None
    if region1 == region2:
        constraint = None

    else:
        flag = False

        if region1[-1] == region2[-1]:
            flag = True

        region1 = dict.fromkeys(region1)
        region2 = dict.fromkeys(region2[::-1])
        length = 1
        for key in region1.keys():
            region1[key] = f"{length}-{length + len(data[key]) - 1}"
            length += len(data[key])

        length += 3
        for key in region2.keys():
            region2[key] = f"{length}-{length + len(data[key]) - 1}"
            length += len(data[key])

        shared_list = [k for k in region1.keys() if k in region2.keys()]
        complementary_1 = [
            (k, k.swapcase()) for k in region1.keys() if k.swapcase() in region1.keys()
        ]
        complementary_2 = [
            (k, k.swapcase()) for k in region2.keys() if k.swapcase() in region2.keys()
        ]

        if len(shared_list) < 2:
            for key in shared_list:
                if constraint is None:
                    constraint = f"P {region1[key]} {region2[key]}\n"
                    for value in complementary_1:
                        constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    for value in complementary_2:
                        constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                else:
                    constraint += f"P {region1[key]} {region2[key]}\n"
                    for value in complementary_1:
                        constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    for value in complementary_2:
                        constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
        else:
            if flag:
                _min = region1[shared_list[0]].split("-")[0]
                _max = region2[shared_list[0]].split("-")[1]
                constraint = f"P {_min}-{_max} {_min}-{_max}\n"
                for value in complementary_1:
                    constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                for value in complementary_2:
                    constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
            else:
                _min_i = region1[shared_list[0]].split("-")[0]
                _max_i = region1[shared_list[-1]].split("-")[1]
                _max_j = region2[shared_list[0]].split("-")[1]
                _min_j = region2[shared_list[-1]].split("-")[0]
                constraint = f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                for value in complementary_1:
                    constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                for value in complementary_2:
                    constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"


def process_mfold_files(self):
    """
    This function creates a dataframe by reading the ".ct" files generated by Mfold and storing information relative to desired regions.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.energy : Matrix used to store the energy loss returned by the Mfold software
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
    """
    for row in range(len(self.energy)):
        for column in range(len(self.energy)):
            region1 = self.regions[row].split("--")
            region2 = self.regions[column].swapcase().split("--")
            region2 = region2[::-1]

            if region1 == region2:
                self.energy[row][column] = 0

    duplicates = {}
    break_counter = 0
    structure = []
    count = 0
    while count < NUMBER_OF_MODIFICATIONS:
        higher = 0
        for row in range(len(self.energy)):
            for column in range(len(self.energy)):
                is_fixed = False
                region1 = self.regions[row].split("--")
                region2 = self.regions[column].split("--")
                for _ in region1:
                    if _ in self.fixed_regions.keys():
                        is_fixed = True
                for _ in region2:
                    if _ in self.fixed_regions.keys():
                        is_fixed = True
                if self.energy[row][column] != None and not is_fixed:
                    if duplicates != {}:
                        if self.energy[row][column] > higher and (
                            duplicates["x"] != row or duplicates["y"] != column
                        ):
                            higher = self.energy[row][column]
                            structure.append({"x": row, "y": column})
                    else:
                        if self.energy[row][column] > higher:
                            higher = self.energy[row][column]
                            structure.append({"x": row, "y": column})

        if higher != 0:
            duplicates = structure[-1]
            count += 1

        break_counter += 1
        if break_counter > LIMIT_OF_TRIALS:
            raise StopIteration

    reset_flag = False
    data = {}
    for _ in range(len(structure)):
        i = structure[_]["x"]
        j = structure[_]["y"]

        data[f"{i}{j}"] = {}

        try:
            with open(f"{i}_{j}.ct", "r") as configfile:
                counter = 0
                max = 0
                for line in configfile:
                    try:
                        if counter > (
                            len(self.strand[i].bases) + len(self.strand[j].bases) + 4
                        ):
                            break
                        if reset_flag:
                            if int(line[26:30]) == 0:
                                if counter <= len(self.strand[i].bases):
                                    end = counter
                                else:
                                    end = counter - 3
                                reset_flag = False
                            else:
                                letter += line[7:8]

                        if int(line[26:30]) > max:
                            letter = ""
                            max = int(line[26:30])
                            reset_flag = True
                            letter += line[7:8]

                            if counter <= len(self.strand[i].bases):
                                index = counter
                            else:
                                index = counter - 3

                        counter += 1
                    except ValueError:
                        counter += 1
                        pass

                data[f"{i}{j}"]["energy"] = self.energy[i][j]
                data[f"{i}{j}"]["letter"] = letter
                data[f"{i}{j}"]["max"] = max
                data[f"{i}{j}"]["index_app"] = index
                data[f"{i}{j}"]["end"] = end
                data[f"{i}{j}"]["shape"] = f"{i}_{j}.png"

        except FileNotFoundError:
            data[f"{i}{j}"]["energy"] = 0
            data[f"{i}{j}"]["letter"] = None
            data[f"{i}{j}"]["max"] = 0
            data[f"{i}{j}"]["index_app"] = 0
            data[f"{i}{j}"]["end"] = 0
            data[f"{i}{j}"]["shape"] = None
            pass

    df = pd.DataFrame.from_dict(data)
    self.thief = df


def manipulate_highlights(self):
    """
    This function is used to manipulate the dataframe generated by process_mfold_files() and highlights the specific fields that are responsable for
    the energy loss.

    Args:
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.header : Region identifiers provided by the user in user_input()
            self.index : Indices of the fields of interest
            self.highlighted : Fields of interest to be highlighted
            self.field : Fields generated by the user in user_input()
    """
    transposed_data = self.thief.transpose()

    for column, energy in enumerate(transposed_data["energy"]):
        region_identifiers = []
        if energy == transposed_data["energy"].max():
            end_of_highlighted_region = transposed_data["end"][column]
            start_of_highlighted_region = transposed_data["index_app"][column]

            if transposed_data["end"][column] - 1 <= len(
                self.strand[
                    int(
                        transposed_data["shape"][column]
                        .replace(".png", "")
                        .split("_")[0]
                    )
                ].bases
            ):
                strand_index = int(
                    transposed_data["shape"][column].replace(".png", "").split("_")[0]
                )

            else:
                strand_index = int(
                    transposed_data["shape"][column].replace(".png", "").split("_")[1]
                )
                end_of_highlighted_region = end_of_highlighted_region - len(
                    self.strand[
                        int(
                            transposed_data["shape"][column]
                            .replace(".png", "")
                            .split("_")[0]
                        )
                    ].bases
                )
                start_of_highlighted_region = start_of_highlighted_region - len(
                    self.strand[
                        int(
                            transposed_data["shape"][column]
                            .replace(".png", "")
                            .split("_")[0]
                        )
                    ].bases
                )

            region_identifiers = [
                self.regions[strand_index].split("--")[_]
                for _ in range(len(self.regions[strand_index].split("--")))
            ]

            data = gc_content([], self)
            length_of_regions = [
                len(data[region_identifiers[_]]) for _ in range(len(region_identifiers))
            ]

            indices = []
            for c in range(len(region_identifiers)):
                _ = 0
                while region_identifiers[c] != self.header[_]:
                    _ += 1
                indices.append(_)

            bases = self.strand[strand_index].bases

            if start_of_highlighted_region > end_of_highlighted_region:
                highlighted_strand = str(
                    f"{bases[:start_of_highlighted_region-1]}[{bases[start_of_highlighted_region-1:]}]"
                )
            else:
                highlighted_strand = str(
                    f"{bases[:start_of_highlighted_region-1]}[{bases[start_of_highlighted_region-1:end_of_highlighted_region-1]}]{bases[end_of_highlighted_region-1:]}"
                )

            single_highlighted_regions = []
            counter = 0

            while counter < len(length_of_regions):
                if (
                    "]" in highlighted_strand[: length_of_regions[counter] + 2]
                    and "[" in highlighted_strand[: length_of_regions[counter] + 2]
                ):
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter] + 2]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] + 2 :
                    ]
                elif (
                    "]" in highlighted_strand[: length_of_regions[counter] + 1]
                    or "[" in highlighted_strand[: length_of_regions[counter] + 1]
                ):
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter] + 1]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] + 1 :
                    ]
                else:
                    single_highlighted_regions.append(
                        highlighted_strand[: length_of_regions[counter]]
                    )
                    highlighted_strand = highlighted_strand[
                        length_of_regions[counter] :
                    ]
                counter += 1

            keep_region = False
            counter = 0
            while counter < len(single_highlighted_regions):
                if (
                    "[" in single_highlighted_regions[counter]
                    and "]" in single_highlighted_regions[counter]
                ) or "]" in single_highlighted_regions[counter]:
                    keep_region = False
                elif "[" in single_highlighted_regions[counter]:
                    keep_region = True
                else:
                    if not keep_region:
                        indices.pop(counter)
                        single_highlighted_regions.pop(counter)
                counter += 1

            for i in range(len(self.thief.columns)):
                if (
                    self.thief.loc["energy"][i] == energy
                    and self.thief.loc["shape"][i] == transposed_data["shape"][column]
                ):
                    self.shape.append(transposed_data["shape"][column])
                    label = self.thief.columns.values.tolist()
                    self.thief = self.thief.drop(labels=[label[i]], axis=1)
                    break

    return single_highlighted_regions, indices


def gc_content(gc, self):
    """
    This function is used to measure the occurences of Gs or Cs in a given strand and also helps delimit and call specific region identifiers.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.population_size : Length of a given region provided by the user in user_input()
            self.header : Region identifiers provided by the user in user_input()
            gc : an empty list to store the gc content measured by this function

    Returns:
            data : a dictionary containing region identifiers as keys and their respective sequences as items
            gc : gc content measured throughout each sequence(# of Gs and # of Cs)
    """
    gc.clear()
    gci = 0
    struct = {}
    regions = []

    bases = [self.strand[i].bases for i in range(len(self.strand))]

    full_sequence = "".join(bases)

    for region in self.regions:
        regions += region.split("--")

    for _ in range(len(self.header)):
        struct[self.header[_]] = self.population_size[_]

    counter = 0
    bases.clear()
    index = 0
    while counter < len(full_sequence):
        bases.append(full_sequence[counter : counter + struct[regions[index]]])
        counter += struct[regions[index]]
        index += 1

    data = {regions[m]: bases[m] for m in range(len(regions))}

    for header, base in data.items():
        gci += base.count("G")
        gci += base.count("C")
        gc.append(gci)
        gci = 0

    return data


class GC_range_picker(QMainWindow):
    """
    This class creates a widget to provide the user with a range picker for a specific GC content range during the randomization process
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def input(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("GC content range picker")
        self.main_layout = QTabWidget()
        self.main_layout.setFixedSize(350, 200)

        self.vbox = QVBoxLayout()
        self.hbox = QHBoxLayout()
        self.slider1 = QSlider()
        self.slider1.setValue(int(self.parent().gc_min * 100))
        self.slider1.setMinimum(0)
        self.slider1.setMaximum(50)
        self.slider1.setTickInterval(10)
        self.slider1.setOrientation(Qt.Horizontal)
        self.slider1.valueChanged.connect(self.on_change_1)

        self.slider2 = QSlider()
        self.slider2.setValue(int(self.parent().gc_max * 100))
        self.slider2.setMinimum(50)
        self.slider2.setMaximum(100)
        self.slider2.setTickInterval(10)
        self.slider2.setOrientation(Qt.Horizontal)
        self.slider2.valueChanged.connect(self.on_change_2)

        self.label1 = QLabel(f"min : {self.slider1.value()}")
        self.label2 = QLabel(f"max : {self.slider2.value()}")
        self.yes = QPushButton("Confirm")

        self.yes.clicked.connect(self.close)
        self.yes.clicked.connect(self.parent().run_randomization)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.label1)
        hbox1.addWidget(self.label2)

        self.vbox.addWidget(
            QLabel(
                "Do you want to randomize the highlighted"
                + "\n"
                + "sequences with the following GC content range ?"
            )
        )
        self.vbox.addLayout(hbox1)
        self.hbox.addWidget(self.slider1)
        self.hbox.addWidget(self.slider2)
        self.vbox.addLayout(self.hbox)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)
        self.setFixedSize(350, 200)
        self.move(600, 350)

        self.show()

    def on_change_1(self):
        """
        This event handler is called when the minimun value is picked from the range picker
        """
        self.label1.setText(f"min : {self.slider1.value()}")
        self.parent().gc_min = self.slider1.value() / 100

    def on_change_2(self):
        """
        This event handler is called when the maximum value is picked from the range picker
        """
        self.label2.setText(f"max : {self.slider2.value()}")
        self.parent().gc_max = self.slider2.value() / 100


class Loop_input_widget(QMainWindow):
    """
    This class creates a widget to provide the user with a range picker for a specific GC content range during the loop calculation process and specifies the number of iterations
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def input(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Iterations required")
        self.main_layout = QTabWidget()
        self.main_layout.setFixedSize(350, 200)

        self.field = QLineEdit()
        self.vbox = QVBoxLayout()
        self.hbox = QHBoxLayout()
        self.slider1 = QSlider()
        self.slider1.setValue(40)
        self.slider1.setMinimum(0)
        self.slider1.setMaximum(50)
        self.slider1.setTickInterval(10)
        self.slider1.setOrientation(Qt.Horizontal)
        self.slider1.valueChanged.connect(self.on_change_1)

        self.slider2 = QSlider()
        self.slider2.setValue(60)
        self.slider2.setMinimum(50)
        self.slider2.setMaximum(100)
        self.slider2.setTickInterval(10)
        self.slider2.setOrientation(Qt.Horizontal)
        self.slider2.valueChanged.connect(self.on_change_2)
        self.field.editingFinished.connect(self.on_change)

        self.label1 = QLabel(f"min : {self.slider1.value()}")
        self.label2 = QLabel(f"max : {self.slider2.value()}")
        self.yes = QPushButton("Confirm")

        self.yes.clicked.connect(self.close)
        self.yes.clicked.connect(self.parent().run_loop)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.label1)
        hbox1.addWidget(self.label2)

        self.vbox.addWidget(QLabel("Please provide the number of iterations"))
        self.vbox.addWidget(self.field)
        self.vbox.addLayout(hbox1)
        self.hbox.addWidget(self.slider1)
        self.hbox.addWidget(self.slider2)
        self.vbox.addLayout(self.hbox)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)
        self.setFixedSize(350, 200)
        self.move(600, 350)

        self.show()

    def on_change(self):
        """
        This event handler is called when the number of iterations is provided and validates the input
        """
        try:
            self.parent().iterator = int(self.field.text())
        except ValueError:
            error = QErrorMessage(self)
            error.showMessage(
                f"Please make sure to provide an integer value greater than 0"
            )

    def on_change_1(self):
        """
        This event handler is called when the minimum value is picked from the range picker
        """
        self.label1.setText(f"min : {self.slider1.value()}")
        self.parent().gc_min = self.slider1.value() / 100

    def on_change_2(self):
        """
        This event handler is called when the maximum value is picked from the range picker
        """
        self.label2.setText(f"max : {self.slider2.value()}")
        self.parent().gc_max = self.slider2.value() / 100


class Export_message(QMainWindow):
    """
    This class creates a widget to provide the user with a window to visualize the configuration and save it
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def export(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Save current configuration")
        self.main_layout = QWidget()

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.vbox = QVBoxLayout()
        self._vbox = QVBoxLayout()
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self._vbox)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)

        self.yes = QPushButton("Confirm")
        self.yes.clicked.connect(self.save_configuration)

        base = ""
        data = gc_content([], self.parent())

        for index in range(len(self.parent().strand)):
            length_of_region = len(self.parent().regions[index].split("--"))
            for _ in range(length_of_region):
                if _ == 0:
                    base = str(data[self.parent().regions[index].split("--")[_]])
                else:
                    base += "--" + str(
                        data[self.parent().regions[index].split("--")[_]]
                    )

            row = QLabel(f"{self.parent().regions[index]}: {base}")
            self._vbox.addWidget(row)

        self.vbox.addWidget(self.scroll)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)

        self.setCentralWidget(self.main_layout)
        self.move(300, 150)
        self.main_layout.adjustSize()
        self.show()

    def save_configuration(self):
        """
        This event handler is called when the user wants to save the configuration and specify the filename
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            params = {}

            data = gc_content([], self.parent())
            for _ in range(len(self.parent().header)):
                self.parent().input_sequence[self.parent().header[_]] = data[
                    self.parent().header[_]
                ]

            params["raw_structure"] = self.parent().raw_structure
            params["mfold_command"] = "./mfold_quik"
            params["boltzmann_factor"] = 1
            params["fixed_regions"] = self.parent().fixed_regions
            params["input_sequence_definitions"] = self.parent().input_sequence
            params["energy_matrix"] = self.parent().energy
            try:
                with open(str(filename[0] + ".dat"), "w") as configfile:
                    yaml.dump(params, configfile)
            except FileNotFoundError:
                pass
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")


class Export_oligos_message(QMainWindow):
    """
    This class creates a widget to provide the user with a window to visualize the oligos and save them
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def export(self):
        self.setWindowTitle("Save current oligos")
        self.main_layout = QWidget()

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.vbox = QVBoxLayout()
        self._vbox = QVBoxLayout()
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self._vbox)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)

        self.yes = QPushButton("Confirm")
        self.yes.clicked.connect(self.save_configuration)

        for _ in range(len(self.parent().regions)):
            row = QLabel(f"{self.parent().regions[_]}: {self.parent().strand[_].bases}")
            self._vbox.addWidget(row)

        self.vbox.addWidget(self.scroll)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)

        self.setCentralWidget(self.main_layout)
        self.move(300, 150)
        self.main_layout.adjustSize()
        self.show()

    def save_configuration(self):
        """
        This event handler is called when the user wants to save the oligos and specify the filename
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            try:
                message = {}
                for _ in range(len(self.parent().regions)):
                    message[self.parent().regions[_]] = self.parent().strand[_].bases

                export = {}
                with open(str(filename[0] + ".dat"), "w") as configfile:
                    for key, value in message.items():
                        key = key.replace("--", "")
                        export[key] = value

                    yaml.dump(export, configfile)
            except FileNotFoundError:
                pass
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")


class Paint_structure(QMainWindow):
    """
    This class creates a widget to provide the user with a structure viewer to visualize the sequence's binding
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def paint(self, x, y):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Structure viewer")
        self._zoom = 0
        self.tabs = QTabWidget()
        self.tabs.setFixedSize(1200, 700)

        current_dir = os.getcwd()
        files = os.listdir(current_dir)

        for file in files:
            if file.endswith(f"{y}_{x}.png"):
                label = QLabel(
                    f"This is the interaction between {self.parent().regions[y]} (from 1 to {len(self.parent().strand[y].bases) + 1}) and {self.parent().regions[x]} (from {len(self.parent().strand[y].bases) + 1} to {len(self.parent().strand[y].bases) + len(self.parent().strand[x].bases)})({file})"
                )

                pixmap = QPixmap(file)
                item = QGraphicsPixmapItem(pixmap)
                scene = QGraphicsScene(self)
                scene.addItem(item)
                self.view = QGraphicsView()
                self.view.setScene(scene)

                tab = QWidget()
                tab.layout = QVBoxLayout()
                tab.layout.addWidget(label)
                tab.layout.addWidget(self.view)
                tab.setLayout(tab.layout)
                self.tabs.addTab(
                    tab, f"{self.parent().regions[y]} and {self.parent().regions[x]}"
                )

                self.setCentralWidget(self.tabs)

                self.setFixedSize(1200, 700)
                self.move(100, 100)
                self.show()
                break

    def keyPressEvent(self, event):
        """
        Allowing zooming capabilites for the structure viewer
        """
        if event.key() == 43:  #  or "+" key
            self._zoom = 1.25
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 45:  #  or "-" key
            self._zoom = 0.8
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 72:  #  or "h" key
            self.view.fitInView(self.view.sceneRect(), Qt.KeepAspectRatio)


class DNA_origami(QWidget):
    """
    This class creates the main widget for this application
    """

    def __init__(self):
        super().__init__()
        self.header = []
        self.check = []
        self.fixed_regions = {}
        self.label = []
        self.regions = []
        self.population_size = []
        self.index = []
        self.input_sequence = {}
        self.field = []
        self.raw_structure = None
        self.automate = False
        self.iterator = 0
        self.counter = 0
        self.thief = None
        self.gc_max = 0.6
        self.gc_min = 0.4
        self.strand = []
        self.shape = []
        self.highlighted = []
        self.energy = []
        self.max = 0
        self.initUI()

    def initUI(self):
        """
        This function defines the display of the main widget and event bindings
        """
        self.btn1 = QPushButton("Specify Structure")
        self.btn1.setFixedSize(150, 70)
        self.btn1.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn1.clicked.connect(self.user_input)
        self.btn2 = QPushButton("Maximum Energy")
        self.btn2.setFixedSize(150, 70)
        self.btn2.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn2.clicked.connect(self.user_max)
        self.btn3 = QPushButton("Calculate" + "\n" + "energy")
        self.btn3.setFixedSize(150, 70)
        self.btn3.setIcon(QIcon("assets/sync-solid.svg"))
        self.btn3.setIconSize(QSize(30, 30))
        self.btn3.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn3.clicked.connect(self.calculate)
        self.btn4 = QPushButton("View/Save" + "\n" + "configuration")
        self.btn4.setFixedSize(150, 70)
        self.btn4.setIcon(QIcon("assets/download-solid.svg"))
        self.btn4.setIconSize(QSize(30, 30))
        self.btn4.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn4.clicked.connect(self.export)
        self.btn5 = QPushButton("Load" + "\n" + "configuration")
        self.btn5.setFixedSize(150, 70)
        self.btn5.setIcon(QIcon("assets/upload-solid.svg"))
        self.btn5.setIconSize(QSize(30, 30))
        self.btn5.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn7 = QPushButton()
        self.btn7.setFixedSize(40, 40)
        self.btn7.setToolTip("Export data")
        self.btn7.setIcon(QIcon("assets/save-solid.svg"))
        self.btn7.setIconSize(QSize(20, 20))
        self.btn7.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn8 = QPushButton("Optimize")
        self.btn8.setFixedSize(150, 70)
        self.btn8.setIconSize(QSize(30, 30))
        self.btn8.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn9 = QPushButton("Calculate" + "\n" + " + " + "\n" + "Optimize")
        self.btn9.setFixedSize(150, 70)
        self.btn9.setIconSize(QSize(30, 30))
        self.btn9.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn10 = QPushButton("Show structure")
        self.btn10.setFixedSize(150, 70)
        self.btn10.setIconSize(QSize(30, 30))
        self.btn10.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn11 = QPushButton("Export oligos")
        self.btn11.setFixedSize(150, 70)
        self.btn11.setIcon(QIcon("assets/download-solid.svg"))
        self.btn11.setIconSize(QSize(30, 30))
        self.btn11.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn5.clicked.connect(self.load)
        self.btn7.clicked.connect(self.output_data)
        self.btn8.clicked.connect(self.randomize_strand)
        self.btn9.clicked.connect(self.loop_calculation)
        self.btn10.clicked.connect(self.display_structure)
        self.btn11.clicked.connect(self.export_oligos)

        self.tabs = QTabWidget()
        self.tabs.setFixedSize(500, 570)

        self.canvas = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.canvas.setFixedSize(490, 450)
        toolbar = NavigationToolbar2QT(self.canvas, self)
        horizontal_toolbar = QHBoxLayout()
        horizontal_toolbar.addWidget(self.btn7)
        horizontal_toolbar.addWidget(toolbar)
        self.tab = QWidget()
        self.tabs.addTab(self.tab, "Energy")

        self.tab.layout = QVBoxLayout()
        self.tab.layout.addWidget(QLabel("Energy matrix for region interaction"))
        self.tab.layout.addWidget(self.canvas)
        self.tab.layout.addLayout(horizontal_toolbar)
        self.tab.setLayout(self.tab.layout)
        self.canvas.mpl_connect("button_press_event", self.render_structure)

        main_layout = QHBoxLayout()

        sub_bottom = QHBoxLayout()
        self.top_layout = QHBoxLayout()
        self.top_layout.setSpacing(30)
        self.center_layout = QFormLayout()
        self.bottom_layout = QHBoxLayout()
        sub_vertical = QVBoxLayout()
        self.bottom_layout.setSpacing(30)
        self.right_side = QVBoxLayout()
        self.left_side = QVBoxLayout()
        self.top_layout.addWidget(self.btn1)
        self.top_layout.addWidget(self.btn10)
        self.top_layout.addWidget(self.btn2)
        sub_vertical.addWidget(self.btn8)
        sub_vertical.addWidget(self.btn9)
        self.bottom_layout.addLayout(sub_vertical)
        self.bottom_layout.addWidget(self.btn3)
        export = QVBoxLayout()
        export.addWidget(self.btn4)
        export.addWidget(self.btn11)
        self.bottom_layout.addLayout(export)
        self.bottom_layout.addWidget(self.btn5)
        self.left_side.addLayout(self.top_layout)

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self.center_layout)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)
        self.left_side.addWidget(self.scroll)
        self.left_side.addLayout(self.bottom_layout)

        self.right_side.addWidget(self.tabs)
        self.progress = QProgressBar()
        self.progress.setAlignment(Qt.AlignHCenter)
        self.progress.setFixedSize(350, 30)
        sub_bottom.addWidget(self.progress)

        self.right_side.addLayout(sub_bottom)
        main_layout.addLayout(self.left_side)
        main_layout.addLayout(self.right_side)
        self.setLayout(main_layout)
        self.setWindowTitle("DNA origami")
        self.move(100, 100)
        self.setFixedSize(1200, 700)
        self.show()

    def user_input(self):
        """
        This function is used to take the user input and send it to render_form() to create the form layout for the input provided.

        Args:
                self.raw_structure : The raw input as inputed by the user from user_input()
        """
        input = QInputDialog()
        text, reply = input.getText(
            self,
            "Input Shape",
            "Enter your desired shape (for example: a25 B25, b25 C25, c25 D25, d25 A25)",
        )

        if reply:
            if str(text) != "":
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)

                self.header.clear()
                self.field.clear()
                self.label.clear()
                self.check.clear()
                self.regions.clear()
                self.fixed_regions = {}
                self.strand.clear()
                self.energy.clear()
                self.population_size.clear()
                self.input_sequence = {}

                try:
                    self.raw_structure = text
                    self.render_form()
                except (KeyError, IndexError):
                    error = QErrorMessage(self)
                    error.showMessage("Please follow the given structure format")

    def render_form(self):
        """
        This function is used to process the input provided by the user and render a form layout containing a header as the region identifier,
        the population size, its GC content, a random sequence generated for this region identifier and a checkbox if this region can be modified.

        Args:
                self.regions : Regions by the user in user_input()
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.input_sequences : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
        """
        self.regions.clear()
        self.header.clear()

        structure = [
            [
                Region(
                    re.findall("\D+", region)[0],
                    int(re.findall("\d+", region)[0]),
                )
                for region in strand
            ]
            for strand in [
                strand.strip().split() for strand in self.raw_structure.split(",")
            ]
        ]

        population_size = []
        for _, struct in enumerate(structure):
            region = ""
            for j in range(len(struct)):
                if not str(struct[j]).split("'")[1] in self.header:
                    self.header.append(str(struct[j]).split("'")[1])
                    population_size.append(
                        int(str(struct[j]).split(" ")[1].split(")")[0])
                    )

                if j == 0:
                    region += str(struct[j]).split("'")[1]
                else:
                    region += "--" + str(struct[j]).split("'")[1]
            self.regions.append(region)

        self.population_size = population_size

        sequence = Sequence.random_sequence(structure, self.fixed_regions)
        self.strand = [
            sequence.build_strand(strand) for strand in sequence.strand_structures
        ]

        if self.input_sequence != {}:
            bases = ""
            for i, region in enumerate(self.regions):
                for _ in region.split("--"):
                    bases += str(self.input_sequence[_])

                self.strand[i].bases = bases
                bases = ""

        for _ in range(len(self.strand)):
            bases = self.strand[_].bases
            while bases.find("AAAAAAAAAA") != -1:
                index = bases.index("AAAAAAAAAA")
                bases = bases[:index] + "T" + bases[index + 1 :]
            while bases.find("TTTTTTTTTT") != -1:
                index = bases.index("TTTTTTTTTT")
                bases = bases[:index] + "A" + bases[index + 1 :]
            while bases.find("CCCCCC") != -1:
                index = bases.index("CCCCCC")
                bases = bases[:index] + "G" + bases[index + 1 :]
            while bases.find("GGGGGG") != -1:
                index = bases.index("GGGGGG")
                bases = bases[:index] + "C" + bases[index + 1 :]
            self.strand[_].bases = bases

        gc = []
        data = gc_content(gc, self)

        for _, header in enumerate(self.header):
            self.label.append(
                QLabel(
                    header
                    + f" {self.population_size[_]} (GC count: "
                    + str(gc[_])
                    + ") "
                )
            )
            self.label[_].setFixedSize(170, 30)
            self.check.append(QCheckBox("Set as fixed region"))

            if header.islower():
                if header in self.fixed_regions.keys():
                    self.field.append(QLineEdit(data[header]))
                    self.check[_].setChecked(True)
                    self.field[_].setEnabled(False)
                    self.field[_].setMaxLength(self.population_size[_])
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[_].setValidator(validator)
                    row = QHBoxLayout()
                    row.addWidget(self.field[_])
                    row.addWidget(self.check[_])
                else:
                    self.field.append(QLineEdit(data[header]))
                    self.field[_].setMaxLength(self.population_size[_])
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[_].setValidator(validator)
                    row = QHBoxLayout()
                    row.addWidget(self.field[_])
                    row.addWidget(self.check[_])
            else:
                self.field.append(QLineEdit(data[header]))
                self.field[_].setEnabled(False)
                row = QHBoxLayout()
                row.addWidget(self.field[_])

            self.field[_].setFixedSize(300, 30)
            self.center_layout.addRow(self.label[_], row)
            self.field[_].editingFinished.connect(self.strand_update)
            self.check[_].stateChanged.connect(self.set_fixed)

    def strand_update(self):
        """
        This function is used to fire after the user updates a sequence in the user fields and performs the modifications in the strand variable.

        Args:
                self.field : Fields generated by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
                self.label : A text box containing a region identifier with its respective gc content
        """
        for _, field in enumerate(self.field):
            field.setStyleSheet("background-color: white")
            if field.isModified():
                text = field.text()

                if len(text) != self.population_size[_]:
                    data = gc_content([], self)
                    field.setText(data[self.header[_]])

                else:
                    uppercase_text = text.upper()
                    uppercase_text = uppercase_text[::-1]

                    complemented_base = (
                        uppercase_text.replace("A", "temp")
                        .replace("T", "A")
                        .replace("temp", "T")
                    )
                    complemented_base = (
                        complemented_base.replace("C", "temp")
                        .replace("G", "C")
                        .replace("temp", "G")
                    )

                    data = gc_content([], self)
                    if self.header[_].islower():
                        for not_used, strand in enumerate(self.strand):
                            if data[self.header[_].lower()] in strand.bases:
                                old_base = strand.bases
                                updated_base = old_base.replace(
                                    data[self.header[_]], text
                                )
                                strand.bases = updated_base

                            if self.header[_].upper() in data.keys():
                                if data[self.header[_].upper()] in strand.bases:
                                    old_base = strand.bases
                                    updated_base = old_base.replace(
                                        data[self.header[_].upper()], complemented_base
                                    )
                                    strand.bases = updated_base

                    if self.header[_].isupper():
                        for not_used, strand in enumerate(self.strand):
                            if data[self.header[_].lower()] in strand.bases:
                                old_base = strand.bases
                                updated_base = old_base.replace(
                                    data[self.header[_].lower()], complemented_base
                                )
                                strand.bases = updated_base

                            if self.header[_].upper() in data.keys():
                                if data[self.header[_].upper()] in strand.bases:
                                    old_base = strand.bases
                                    updated_base = old_base.replace(
                                        data[self.header[_].upper()], text
                                    )
                                    strand.bases = updated_base

                    gc = []
                    updated_data = gc_content(gc, self)
                    self.label[_].setText(
                        self.header[_]
                        + f" {self.population_size[_]} (GC count: "
                        + str(gc[_])
                        + ") "
                    )

                    for region_identifier, base in updated_data.items():
                        if base != data[region_identifier]:
                            for index, header in enumerate(self.header):
                                if region_identifier == header:
                                    self.label[index].setText(
                                        region_identifier
                                        + f" {self.population_size[_]} (GC count: "
                                        + str(gc[_])
                                        + ") "
                                    )
                                    self.field[index].setText(base)

    def set_fixed(self):
        """
        This function is used to define fixed regions by the user and store them in a dictionary variable.

        Args:
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
        """
        self.fixed_regions = {}
        for _, check in enumerate(self.check):
            if check.isChecked() == True:
                self.field[_].setEnabled(False)
                data = gc_content([], self)
                self.fixed_regions[self.header[_]] = data[self.header[_]]
                self.fixed_regions[self.header[_].upper()] = data[
                    self.header[_].upper()
                ]
            if check.isChecked() == False:
                if self.header[_].islower():
                    self.field[_].setEnabled(True)

    def user_max(self):
        """
        This function is used to specify the max value that is shown in the heatmap and is defined by the user with a validation step.

        Args:
                self.max : A value set by the user to rescale the heatmap max value
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        energy = QInputDialog()
        text, reply = energy.getText(
            self, "Maximum Energy", "Enter the maximum energy value for this shape:"
        )
        if reply:
            if str(text) != "":
                if float(text) >= 0:
                    self.max = float(text)
                    if self.energy != 0:
                        minimum = [min(self.energy[_]) for _ in range(len(self.energy))]

                        if self.max > min(minimum):
                            self.update()
                        else:
                            error = QErrorMessage(self)
                            error.showMessage(
                                "This value is less than the minimum possible value"
                            )
                            self.max = 0

                else:
                    error = QErrorMessage(self)
                    error.showMessage("Please give a positive value")

    def export_oligos(self):
        """
        This function is used to export the current oligos.

        Args:
                self.regions : Regions provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
        """
        message = {
            self.regions[_]: self.strand[_].bases for _ in range(len(self.regions))
        }

        if message != {}:
            window = Export_oligos_message(self)
            window.export()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a configuration")

    def export(self):
        """
        This function is used to export the current configuration and respects the upload format required by the application.

        Args:
                self.regions : Regions provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
        """
        message = {}
        data = gc_content([], self)

        for i in range(len(self.strand)):
            j = len(self.regions[i].split("--"))
            for _ in range(j):
                if _ == 0:
                    message[self.regions[i]] = str(data[self.regions[i].split("--")[_]])
                else:
                    message[self.regions[i]] += "--" + str(
                        data[self.regions[i].split("--")[_]]
                    )

        if message != {}:
            window = Export_message(self)
            window.export()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a configuration")

    def display_structure(self):
        """
        This function is used to view the current structure.

        Args:
                self.raw_structure : The raw input as inputed by the user from user_input()
        """
        window = QMessageBox()
        reply = window.question(
            self,
            "Current structure is",
            str(self.raw_structure),
            QMessageBox.Close,
            0,
        )

    def load(self):
        """
        This function is responsable for the upload fonctionality of the application and takes in a ".dat" file structured as the export format defined.

        Args:
                self.header : Region identifiers provided by the user in user_input()
                self.field : Fields generated by the user in user_input()
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.regions : Regions provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.population_size : Length of a given region provided by the user in user_input()
                self.input_sequence : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        filename = QFileDialog.getOpenFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if not filename[0].endswith(".dat"):
                error = QErrorMessage(self)
                error.showMessage("Please upload a file with .dat extension")
            else:
                try:
                    while self.center_layout.count() != 0:
                        self.center_layout.removeRow(0)

                    self.header.clear()
                    self.field.clear()
                    self.label.clear()
                    self.check.clear()
                    self.regions.clear()
                    self.fixed_regions = {}
                    self.highlighted.clear()
                    self.index.clear()
                    self.strand.clear()
                    self.population_size.clear()
                    self.input_sequence = {}
                    with open(filename[0], "r") as configfile:
                        params = yaml.load(configfile, Loader=yaml.FullLoader)
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions = params["fixed_regions"]
                        self.input_sequence = params["input_sequence_definitions"]
                        self.render_form()
                        self.update()

                except FileNotFoundError:
                    pass
                except TypeError:
                    error = QErrorMessage(self)
                    error.showMessage("Please upload a file with .dat extension")
                except KeyError:
                    error = QErrorMessage(self)
                    error.showMessage("Please respect the configuration file format")

    def calculate(self):
        """
        This function is responsable for the call to Mfold software and stores the returned energy in a matrix variable.
        It also makes sure that the gc content boundaries are respected.

        Args:
                self.strand : Structure class used to define the strand sequences
                self.header : Region identifiers provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.field : Fields generated by the user in user_input()
        """
        self.btn3.setEnabled(False)
        flag_range = False
        index = 0

        gc = []
        _ = gc_content(gc, self)

        for _ in range(len(gc)):
            if (gc[_] / self.population_size[_]) >= self.gc_min and (
                gc[_] / self.population_size[_]
            ) <= self.gc_max:
                flag_range = True
            else:
                index = _
                flag_range = False
                break

        if self.strand == []:
            error = QErrorMessage(self)
            error.showMessage("Please provide a structure")
            self.btn3.setEnabled(True)

        else:
            if flag_range:
                for _ in range(len(self.field)):
                    self.field[_].setToolTip("")

                try:
                    self.automate = False
                    self.run_calculation()
                    process_mfold_files(self)
                    self.highlight_thief()
                    clear_files()
                    self.update()
                    self.progress.setFormat("DONE")
                    self.btn3.setEnabled(True)
                    self.automate = False
                except StopIteration:
                    error = QErrorMessage(self)
                    message = list(self.fixed_regions.keys())
                    message = [x for x in message if x.islower()]
                    message = ", ".join(message)
                    error.showMessage(
                        f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                    )
                    self.progress.setFormat("DONE")
                    self.progress.setValue(100)
                    clear_files()
                    self.btn3.setEnabled(True)
                    self.automate = True
            else:
                if gc[index] / self.population_size[index] < self.gc_min:
                    if self.header[index].islower():
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("A", "G", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("T", "G", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                    else:
                        for j, header in enumerate(self.header):
                            if header.islower():
                                if header == self.header[index].lower():
                                    index = j
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("A", "G", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("T", "G", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                if gc[index] / self.population_size[index] > self.gc_max:
                    if self.header[index].islower():
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("G", "A", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("C", "A", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                    else:
                        for j, header in enumerate(self.header):
                            if header.islower():
                                if header == self.header[index].lower():
                                    index = j
                        current_text = self.field[index].text()
                        previous_text = current_text
                        current_text = current_text.replace("G", "A", 1)
                        if previous_text == current_text:
                            current_text = current_text.replace("C", "A", 1)
                        self.field[index].setText(current_text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

    def run_calculation(self):
        """
        This function initiates the call to the mfold software and populates the energy matrix of the main class while updating the progress.

        Args:
                self.progress : Progress bar variable for live update on the main widget
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.strand : Structure class used to define the strand sequences
                self.region : Regions provided by the user in user_input()

        """
        mfold = Mfold(output_folder="./", mfold_command="mfold_quik")
        if not self.automate:
            self.progress.setFormat("PROGRESSING")
        self.energy = [[None for strand1 in self.strand] for strand2 in self.strand]

        for i, strand1 in enumerate(self.strand):
            if not self.automate:
                self.progress.setValue(int((i / len(self.strand)) * 100))
            for j, strand2 in enumerate(self.strand):
                region1 = self.regions[i].split("--")
                region2 = self.regions[j].swapcase().split("--")
                region2 = region2[::-1]

                mfold.run(
                    strand1,
                    strand2,
                    set_constraints(self, region1, region2),
                    f"{i}_{j}.seq",
                    f"{i}_{j}.aux",
                )
                with open(f"{i}_{j}.det", "r") as configfile:
                    for line in configfile:
                        if line.startswith(" dG = "):
                            self.energy[i][j] = abs(float(line[10:15]))
                            break

        if not self.automate:
            self.progress.setValue(100)

    def figure_generation(self):
        """
        This function is responsable for the structure viewer generated images.

        Args:
                self.shape : Indices to identify the interaction to be generated
                self.strand : Structure class used to define the strand sequences
                self.regions : Regions provided by the user in user_input()
        """
        for e in self.shape:
            shape = e.replace(".png", "").split("_")
            shape = [int(i) for i in shape]
            with open(f"{shape[0]}_{shape[1]}.ct", "r") as configfile:
                counter = 0
                maximum_index = 0
                for line in configfile:
                    if line[7:8] == "d":
                        counter += 1
                        continue
                    if counter > (
                        len(self.strand[shape[0]].bases)
                        + len(self.strand[shape[1]].bases)
                        + 4
                    ):
                        break
                    if int(line[26:30]) > maximum_index:
                        maximum_index = int(line[26:30])
                    counter += 1

            with open(f"{shape[0]}_{shape[1]}.ct", "r") as configfile:
                nodes_list = []
                flag = False
                G = nx.MultiDiGraph()

                labels = {}
                text = ""
                counter = 0
                before = 0
                center = 0
                extra = 0
                for line in configfile:
                    if line[7:8] == "d":
                        exit = int(line[3:6])
                        continue

                    if line[7:8] == "L":
                        continue

                    if int(line[26:30]) == maximum_index:
                        flag = True

                    if counter < len(self.strand[shape[0]].bases):
                        before = int(line[12:15])
                        center = int(line[3:6])
                        nodes_list.append(before)
                        G.add_edge(before, center, color="black", weight=100)

                        if counter == 1:
                            G.add_node(
                                f"{self.regions[shape[0]]}:{counter}",
                                weight=f"{self.regions[shape[0]]}:{counter}",
                            )
                            labels[f"{self.regions[shape[0]]}:{counter}"] = f"{counter}"
                            G.add_edge(
                                f"{self.regions[shape[0]]}:{counter}",
                                0,
                                color="black",
                                weight=100,
                            )

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[shape[0]]}:{counter+1}",
                                weight=f"{self.regions[shape[0]]}:{counter+1}",
                            )
                            labels[
                                f"{self.regions[shape[0]]}:{counter+1}"
                            ] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[shape[0]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if int(line[26:30]) > 0 or int(line[26:30]) != 0:
                            if flag:
                                if int(line[26:30]) < len(self.strand[shape[0]].bases):
                                    extra = int(line[26:30])
                                else:
                                    extra = int(int(line[26:30]) - 4)
                                G.add_edge(before, extra, color="red", weight=200)
                            else:
                                if int(line[26:30]) < len(self.strand[shape[0]].bases):
                                    extra = int(line[26:30])
                                else:
                                    extra = int(int(line[26:30]) - 4)
                                if not G.has_edge(extra, before):
                                    if extra != 0:
                                        G.add_edge(
                                            before, extra, color="black", weight=200
                                        )
                        else:
                            flag = False

                        counter += 1

                    else:
                        before = int(line[12:15]) - 3
                        center = int(line[3:6]) - 3
                        if int(line[26:30]) < len(self.strand[shape[0]].bases):
                            extra = int(int(line[26:30]) - 1)
                            if extra <= 0:
                                extra = 0
                        else:
                            extra = int(int(line[26:30]) - 4)
                        nodes_list.append(before)

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[shape[1]]}:{counter+1}",
                                weight=f"{self.regions[shape[1]]}:{counter+1}",
                            )
                            labels[
                                f"{self.regions[shape[1]]}:{counter+1}"
                            ] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[shape[1]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if exit == int(line[3:6]):
                            if line[7:8] == "d":
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break
                            else:
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break

                        G.add_edge(before, center, color="black", weight=100)
                        if extra != 0 or extra > 0:
                            if flag:
                                G.add_edge(before, extra, color="red", weight=200)
                            else:
                                if not G.has_edge(extra, before):
                                    G.add_edge(before, extra, color="black", weight=200)
                        else:
                            flag = False

                        counter += 1

                sequence = self.strand[shape[0]].bases + self.strand[shape[1]].bases

                for _, t in enumerate(sequence):
                    G.add_node(nodes_list[_], weight=t)
                    labels[_] = G.nodes[_]["weight"]

                options = {
                    "linewidths": 2,
                    "alpha": 0.8,
                    "node_color": "white",
                    "width": 2,
                    "arrowstyle": "-",
                    "arrowsize": 2,
                    "node_size": 90,
                    "font_size": 8,
                }

                colors = nx.get_edge_attributes(G, "color").values()

                pos = nx.kamada_kawai_layout(G, weight="weight")

                nx.draw(
                    G,
                    pos=pos,
                    with_labels=True,
                    labels=labels,
                    edge_color=colors,
                    **options,
                )

                plt.savefig(e, dpi=300)
                plt.close()
                plt.clf()

        current_dir = os.getcwd()
        files = os.listdir(current_dir)

        for item in files:
            if item.endswith(f".png"):
                if not item in self.shape:
                    os.remove(os.path.join(current_dir, item))

        self.shape.clear()

    def highlight_thief(self):
        """
        This function is used to highlighted the fields responsable for the energy loss binding the different strands.

        Args:
                self.highlighted : a list of sequences that are responsable for the energy loss found in highlight_thief()
                self.index : a list of indices corresponding to the sequences in self.highlighted
        """
        self.highlighted.clear()
        self.index.clear()
        self.shape.clear()

        for _ in range(len(self.field)):
            self.field[_].setToolTip("")
            self.field[_].setStyleSheet("background-color:white")

        while len(self.shape) < NUMBER_OF_MODIFICATIONS:
            highlighted, indices = manipulate_highlights(self)
            self.highlighted += highlighted
            self.index += indices

        if not self.automate:
            self.figure_generation()

        counter = 0
        while counter < len(self.highlighted):
            if self.header[self.index[counter]].isupper():
                complemented = (
                    self.highlighted[counter][::-1]
                    .replace("C", "temp")
                    .replace("G", "C")
                    .replace("temp", "G")
                )
                complemented = (
                    complemented.replace("]", "temp")
                    .replace("[", "]")
                    .replace("temp", "[")
                )
                complemented = (
                    complemented.replace("A", "temp")
                    .replace("T", "A")
                    .replace("temp", "T")
                )

                self.highlighted[counter] = complemented
                index = self.header.index(self.header[self.index[counter]].lower())
                self.index[counter] = index

            counter += 1

        for d in range(len(self.index)):
            text = self.field[self.index[d]].toolTip()
            if text != "":
                if text != self.highlighted[d]:
                    self.field[self.index[d]].setToolTip(
                        text + "\n" + self.highlighted[d] + "\n"
                    )
            else:
                self.field[self.index[d]].setToolTip(self.highlighted[d])
            self.field[self.index[d]].setStyleSheet("background-color:red")

    def render_structure(self, event):
        """
        This function is responsable for the event handling during a click on a square in the heatmap figure
        """
        self.new_widget = Paint_structure(self)
        try:
            x = int(np.round(event.xdata))
            y = int(np.round(event.ydata))
            self.new_widget.paint(x, y)
        except TypeError:
            pass

    def randomize_strand(self):
        """
        This function is used to automatically correct the energy loss found in run_calculate().

        Args:
                self.automate : a flag used to bypass loop_calculation()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                    and associated sequence as item
        """
        if not self.automate:
            gc_popup = GC_range_picker(self)
            gc_popup.input()
        else:
            try:
                self.run_randomization()
            except StopIteration:
                error = QErrorMessage(self)
                message = list(self.fixed_regions.keys())
                message = [x for x in message if x.islower()]
                message = ", ".join(message)
                error.showMessage(
                    f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                )
                self.progress.setFormat("DONE")
                self.progress.setValue(100)
                self.update()
                clear_files()
                self.btn3.setEnabled(True)
                self.btn8.setEnabled(True)
                self.automate = False

    def run_randomization(self):
        if self.highlighted == []:
            error = QErrorMessage(self)
            error.showMessage(
                "Please run the calculation once again to highlight regions"
            )

        else:
            self.btn8.setEnabled(False)
            self.progress.setFormat("Randomizing")
            self.trials = 0
            params = {}
            data = gc_content([], self)
            self.input_sequence = {
                self.header[_]: data[self.header[_]] for _ in range(len(self.header))
            }

            params["raw_structure"] = self.raw_structure
            params["energy_matrix"] = self.energy
            params["fixed_regions"] = self.fixed_regions
            params["input_sequence_definitions"] = self.input_sequence
            params["highlighted"] = self.highlighted
            params["index"] = self.index
            params["shape"] = self.shape

            self.progress.setValue(int((self.trials / LIMIT_OF_TRIALS) * 100))
            self.automate = False
            new_maximum, current_max = self.randomize_validate_randomization(params)

            if new_maximum > current_max:
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)

                self.header.clear()
                self.field.clear()
                self.label.clear()
                self.check.clear()
                self.input_sequence = {}

                self.raw_structure = params["raw_structure"]
                self.energy = params["energy_matrix"]
                self.fixed_regions = params["fixed_regions"]
                self.input_sequence = params["input_sequence_definitions"]
                self.index = params["index"]
                self.highlighted = params["highlighted"]
                self.shape = params["shape"]

                self.render_form()

            self.progress.setFormat("Generating structures")
            self.progress.setValue(100)
            self.automate = True

            self.run_calculation()
            process_mfold_files(self)
            self.automate = False
            self.highlight_thief()
            self.update()

            self.progress.setFormat("DONE")
            self.btn3.setEnabled(True)
            self.btn8.setEnabled(True)
            clear_files()

    def randomize_validate_randomization(self, params):
        higher = 0
        for i in range(len(self.energy)):
            for j in range(len(self.energy)):
                if self.energy[i][j] != None:
                    if self.energy[i][j] > higher:
                        higher = self.energy[i][j]

        current_max = higher
        for iteration in range(LIMIT_OF_TRIALS):
            flag = False
            counter = 0
            while counter < len(self.highlighted):
                fields = []

                for a, highlight in enumerate(self.highlighted):
                    text = ""

                    for b in highlight:
                        if b == "]":
                            flag = False

                        elif flag:
                            text += random.choice(["G", "T", "C", "A"])

                        elif b == "[":
                            flag = True

                        else:
                            text += b

                    fields.append(text)

                gci = 0
                for _ in fields[counter]:
                    if _ == "C" or _ == "G":
                        gci += 1

                if (gci / self.population_size[self.index[counter]]) < self.gc_min or (
                    gci / self.population_size[self.index[counter]]
                ) > self.gc_max:
                    if "]" in self.highlighted[counter]:
                        flag = False

                    if (
                        "[" in self.highlighted[counter]
                        and not "]" in self.highlighted[counter]
                    ):
                        flag = True
                    continue

                else:
                    if self.index.count(self.index[counter]) > 1:
                        indices = [
                            i
                            for i, x in enumerate(self.index)
                            if x == self.index[counter]
                        ]
                        indices.pop(0)

                        for i in indices:
                            complemented = self.highlighted[i]

                            new_indices_o = [
                                j
                                for j in range(len(complemented))
                                if complemented.startswith("[", j)
                            ]

                            new_indices_c = [
                                j
                                for j in range(len(complemented))
                                if complemented.startswith("]", j)
                            ]
                            complemented = [c for c in fields[counter]]
                            for k in new_indices_o:
                                complemented.insert(k, "[")

                            for l in new_indices_c:
                                complemented.insert(l, "]")

                            complemented = "".join(complemented)
                            self.highlighted[i] = complemented

                    for i in range(len(self.header)):
                        if self.header[self.index[counter]].islower():
                            if (
                                self.header[i]
                                == self.header[self.index[counter]].upper()
                            ):
                                indices = [
                                    j for j, x in enumerate(self.index) if x == i
                                ]
                                for k in indices:
                                    complemented = self.highlighted[k]
                                    new_indices_o = [
                                        j
                                        for j in range(len(complemented))
                                        if complemented.startswith("[", j)
                                    ]

                                    new_indices_c = [
                                        j
                                        for j in range(len(complemented))
                                        if complemented.startswith("]", j)
                                    ]
                                    complemented = (
                                        fields[counter][::-1]
                                        .replace("A", "temp")
                                        .replace("T", "A")
                                        .replace("temp", "T")
                                    )
                                    complemented = (
                                        complemented.replace("C", "temp")
                                        .replace("G", "C")
                                        .replace("temp", "G")
                                    )
                                    complemented = [c for c in complemented]
                                    for l in new_indices_o:
                                        complemented.insert(l, "[")

                                    for m in new_indices_c:
                                        complemented.insert(m, "]")

                                    complemented = "".join(complemented)
                                    self.highlighted[k] = complemented

                        if self.header[self.index[counter]].isupper():
                            if (
                                self.header[i]
                                == self.header[self.index[counter]].lower()
                            ):
                                indices = [
                                    j for j, x in enumerate(self.index) if x == i
                                ]
                                for k in indices:
                                    complemented = self.highlighted[k]

                                    new_indices_o = [
                                        j
                                        for j in range(len(complemented))
                                        if complemented.startswith("[", j)
                                    ]

                                    new_indices_c = [
                                        j
                                        for j in range(len(complemented))
                                        if complemented.startswith("]", j)
                                    ]
                                    complemented = (
                                        fields[counter][::-1]
                                        .replace("A", "temp")
                                        .replace("T", "A")
                                        .replace("temp", "T")
                                    )
                                    complemented = (
                                        complemented.replace("C", "temp")
                                        .replace("G", "C")
                                        .replace("temp", "G")
                                    )
                                    complemented = [c for c in complemented]
                                    for l in new_indices_o:
                                        complemented.insert(l, "[")
                                    for m in new_indices_c:
                                        complemented.insert(m, "]")

                                    complemented = "".join(complemented)

                                    self.highlighted[k] = complemented

                    self.field[self.index[counter]].setText(fields[counter])
                    self.field[self.index[counter]].setModified(True)
                    self.strand_update()

                    try:
                        if "]" in self.highlighted[counter]:
                            if "[" in self.highlighted[counter]:
                                counter += 1
                                continue
                            flag = True
                    except IndexError:
                        pass

                    counter += 1

            self.progress.setFormat("Testing randomization")

            previous_state = self.automate
            self.btn3.setEnabled(False)
            self.automate = True
            self.run_calculation()
            self.automate = previous_state
            higher = 0
            for i in range(len(self.energy)):
                for j in range(len(self.energy)):
                    if self.energy[i][j] != None:
                        if self.energy[i][j] > higher:
                            higher = self.energy[i][j]

            new_maximum = higher
            if new_maximum > current_max and self.trials < LIMIT_OF_TRIALS:
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)

                self.header.clear()
                self.field.clear()
                self.label.clear()
                self.check.clear()
                self.input_sequence = {}
                self.energy.clear()

                self.raw_structure = params["raw_structure"]
                self.energy = params["energy_matrix"]
                self.fixed_regions = params["fixed_regions"]
                self.input_sequence = params["input_sequence_definitions"]
                self.highlighted = params["highlighted"]
                self.index = params["index"]
                self.shape = params["shape"]

                self.render_form()

                self.trials += 1
                if not self.automate:
                    self.progress.setValue(int((self.trials / LIMIT_OF_TRIALS) * 100))

            else:
                break
        return new_maximum, current_max

    def loop_calculation(self):
        """
        This function is used to start a widget to help the user specify the number of iterations and gc content range during the loop calculation/randomization process

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
        """
        self.iterator = 0
        if not self.automate:
            loop_widget = Loop_input_widget(self)
            loop_widget.input()
        else:
            try:
                self.run_loop()
                clear_files()
                self.automate = False

            except StopIteration:
                error = QErrorMessage(self)
                message = list(self.fixed_regions.keys())
                message = [x for x in message if x.islower()]
                message = ", ".join(message)
                error.showMessage(
                    f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                )
                self.progress.setFormat("DONE")
                self.progress.setValue(100)
                self.update()
                clear_files()
                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.counter = 0
                self.iterator = 0
                self.automate = False

                self.btn3.setEnabled(True)
                self.btn8.setEnabled(True)
                self.btn9.setEnabled(True)

    def run_loop(self):
        """
        This function is used to create iteration in the process of lowering energy loss by create loops of calculation and randomization.

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
                self.counter : a counter for the current iteration in loop_calculation()
                self.progress : a progressbar component used in the main layout
                self.field : Fields generated by the user in user_input()
        """
        if isinstance(self.iterator, int):
            if self.iterator <= 0:
                error = QErrorMessage(self)
                error.showMessage(
                    f"Please make sure to provide an integer value greater than 0"
                )

            elif self.field == []:
                error = QErrorMessage(self)
                error.showMessage(f"Please make sure to provide a structure")

            else:
                self.btn9.setEnabled(False)
                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.automate = True
                self.trials = 0
                self.progress.setFormat("Calculating")
                self.btn3.setEnabled(False)
                self.btn8.setEnabled(False)
                for count in range(self.iterator):
                    self.progress.setValue(int((self.counter / self.iterator) * 100))

                    self.automate = True

                    self.progress.setFormat("Calculating")
                    self.run_calculation()
                    process_mfold_files(self)
                    self.highlighted.clear()
                    self.index.clear()
                    self.shape.clear()

                    for _ in range(NUMBER_OF_MODIFICATIONS):
                        highlighted, indices = manipulate_highlights(self)
                        self.highlighted += highlighted
                        self.index += indices

                    self.progress.setFormat("Randomizing")

                    params = {}
                    data = gc_content([], self)
                    data = gc_content([], self)
                    self.input_sequence = {
                        self.header[_]: data[self.header[_]]
                        for _ in range(len(self.header))
                    }

                    params["raw_structure"] = self.raw_structure
                    params["fixed_regions"] = self.fixed_regions
                    params["input_sequence_definitions"] = self.input_sequence
                    params["energy_matrix"] = self.energy
                    params["highlighted"] = self.highlighted
                    params["index"] = self.index
                    params["shape"] = self.shape

                    self.automate = True
                    new_maximum, current_max = self.randomize_validate_randomization(
                        params
                    )

                    if new_maximum > current_max:
                        while self.center_layout.count() != 0:
                            self.center_layout.removeRow(0)

                        self.header.clear()
                        self.field.clear()
                        self.label.clear()
                        self.check.clear()
                        self.input_sequence = {}
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions = params["fixed_regions"]
                        self.input_sequence = params["input_sequence_definitions"]
                        self.highlighted = params["highlighted"]
                        self.index = params["index"]
                        self.shape = params["shape"]

                        self.render_form()

                    self.counter += 1

                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.counter = 0
                self.iterator = 0

                self.progress.setFormat("Generating structures")
                self.progress.setValue(100)
                self.automate = True

                self.run_calculation()
                process_mfold_files(self)
                self.automate = False
                self.highlight_thief()
                self.update()
                self.progress.setFormat("DONE")

                clear_files()
                self.btn9.setEnabled(True)
                self.btn8.setEnabled(True)
                self.btn3.setEnabled(True)

    def output_data(self):
        """
        This function is used to export the heatmap energy matrix in a ".csv" file.

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region provided by the user in user_input()
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if self.energy == []:
                error = QErrorMessage(self)
                error.showMessage(f"There is no heatmap plot at the moment")
            else:
                try:
                    with open(filename[0] + ".csv", "w") as configfile:
                        columns = self.regions
                        df = pd.DataFrame(self.energy, columns=columns)
                        df.to_csv(configfile, index=False)
                except FileNotFoundError:
                    pass

    def update(self):
        """
        This function is used to generate the heatmap from the energy matrix found in calculate().

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region class used to define the regions defined
                self.canvas : A matplotlib figure class to draw the heatmap from the energy matrix stored in calculate()
                self.max : A value set by the user to rescale the heatmap max value
        """
        if self.energy == []:
            error = QErrorMessage(self)
            error.showMessage(f"The energy matrix is empty!")

        else:
            self.canvas.figure.clear()
            ax = self.canvas.figure.add_subplot(111)

            ticks = self.regions

            if self.max != 0:
                try:
                    im = ax.imshow(
                        self.energy,
                        cmap="plasma",
                        interpolation="nearest",
                        vmax=self.max,
                    )
                except (TypeError, UnboundLocalError):
                    self.update()

            else:
                try:
                    im = ax.imshow(self.energy, cmap="plasma", interpolation="nearest")
                except (TypeError, UnboundLocalError):
                    self.update()

            ax.set_xticks(np.arange(len(ticks)))
            ax.set_yticks(np.arange(len(ticks)))
            ax.set_xticklabels(
                ticks, fontsize=10, rotation=45, ha="right", linespacing=2
            )
            ax.set_yticklabels(ticks, fontsize=10)

            ax.figure.colorbar(
                im,
                label="Kcal/mol",
                orientation="vertical",
            )

            current_dir = os.getcwd()
            files = os.listdir(current_dir)

            to_highlight = {}
            to_avoid = ""
            for count in range(NUMBER_OF_MODIFICATIONS):
                for file in files:
                    if file.endswith(".png"):
                        item = file.replace(".png", "")
                        i = int(item.split("_")[0])
                        j = int(item.split("_")[1])
                        if to_avoid != "":
                            if i != int(to_avoid.split("-")[0]) or j != int(
                                to_avoid.split("-")[1]
                            ):
                                to_highlight[count] = {"x": i, "y": j}
                        else:
                            to_highlight[count] = {"x": i, "y": j}

                to_avoid = (
                    str(to_highlight[count]["x"]) + "-" + str(to_highlight[count]["y"])
                )

            for _ in range(len(to_highlight)):
                ax.add_patch(
                    Rectangle(
                        (to_highlight[_]["y"] - 0.5, to_highlight[_]["x"] - 0.5),
                        1,
                        1,
                        edgecolor="red",
                        fill=False,
                        lw=3,
                    )
                )

            ax.format_coord = lambda x, y: f"Energy"

            self.canvas.draw()

    def closeEvent(self, event):
        """
        This function is used to close/exit the main widget.
        """
        pop_message = QMessageBox()
        reply = pop_message.question(
            self,
            "Confirmation step",
            "Are you sure to quit?",
            QMessageBox.Yes | QMessageBox.No,
            0,
        )
        if reply == QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()


if __name__ == "__main__":
    window = QApplication(sys.argv)
    view = DNA_origami()
    sys.exit(window.exec_())
