import faulthandler
import json
import os
import random
import re
import sys

import yaml
from matplotlib.backends.backend_qt5 import NavigationToolbar2QT

faulthandler.enable()

# Import matplotlib for heatmap rendering
import matplotlib
import networkx as nx
from matplotlib.patches import Rectangle

# Import QApplication and the required widgets from PyQt5.QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

matplotlib.use("QT5Agg")
import matplotlib.pyplot as plt

# Import pandas and numpy for data manipulation
import numpy as np
import pandas as pd
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

from genetic import Sequence

# Import mfold required libraries
from mfold_library import Mfold, Region

# To do:
# Fix multiple checks blocking calculations V
# show structure window V
# Fix repeated regions V
# Check for more than 10 A/T in a row and 6 C/G in a row V
# Button to export strands V
# Exception for fixed regions (move to second highest) V
# Zero energy error V


def clear_files():
    """
    This function is called to clear the files generated by the Mfold software
    """
    extensions = [
        ".seq",
        ".ct",
        ".det",
        ".out",
        ".pnt",
        ".sav",
        ".test",
        ".log",
        ".cmd",
        ".aux",
        ".con",
    ]
    cwd = os.getcwd()
    test = os.listdir(cwd)

    for item in test:
        for extension in extensions:
            if item.endswith(extension):
                os.remove(os.path.join(cwd, item))


def find_thief(self):
    """
    This function creates a dataframe by reading the ".ct" files generated by Mfold and storing information relative to desired regions.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.energy : Matrix used to store the energy loss returned by the Mfold software
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
    """
    for i in range(len(self.energy)):
        for j in range(len(self.energy)):
            region1 = self.regions[i].split("--")
            region2 = self.regions[j].swapcase().split("--")
            region2 = region2[::-1]

            if region1 == region2:
                self.energy[i][j] = 0

    to_avoid = {}
    tries = 0
    flag = False
    structure = []
    count = 0
    while count < 2:
        higher = 0
        for i in range(len(self.energy)):
            for j in range(len(self.energy)):
                flag = False
                region1 = self.regions[i].split("--")
                region2 = self.regions[j].split("--")
                for _ in region1:
                    if _ in self.fixed_regions.keys():
                        flag = True
                for _ in region2:
                    if _ in self.fixed_regions.keys():
                        flag = True
                if self.energy[i][j] != None and not flag:
                    if to_avoid != {}:
                        if self.energy[i][j] > higher and (
                            to_avoid["x"] != i or to_avoid["y"] != j
                        ):
                            higher = self.energy[i][j]
                            structure.append({"x": i, "y": j})
                    else:
                        if self.energy[i][j] > higher:
                            higher = self.energy[i][j]
                            structure.append({"x": i, "y": j})

        if higher != 0:
            to_avoid = structure[-1]
            count += 1

        tries += 1
        if tries > 5:
            raise StopIteration

    flag = False
    data = {}
    for count in range(len(structure)):
        i = structure[count]["x"]
        j = structure[count]["y"]

        data[f"{i}{j}"] = {}

        try:
            with open(f"{i}_{j}.ct", "r") as configfile:
                counter = 0
                max = 0
                for line in configfile:
                    try:
                        if flag and int(line[26:30]) == 0:
                            if counter <= len(self.strand[i].bases):
                                end = counter
                            else:
                                end = counter - 3
                            flag = False
                        if flag:
                            letter += line[7:8]

                        if int(line[26:30]) > max:
                            letter = ""
                            max = int(line[26:30])
                            flag = True
                            letter += line[7:8]

                            if counter <= len(self.strand[i].bases):
                                index = counter
                            else:
                                index = counter - 3

                            index1 = counter

                        if counter > (
                            len(self.strand[i].bases) + len(self.strand[j].bases) + 4
                        ):
                            break
                        counter += 1
                    except ValueError:
                        counter += 1
                        pass

                data[f"{i}{j}"]["energy"] = self.energy[i][j]
                data[f"{i}{j}"]["letter"] = letter
                data[f"{i}{j}"]["max"] = max
                data[f"{i}{j}"]["index_app"] = index
                data[f"{i}{j}"]["index_ct"] = index1
                data[f"{i}{j}"]["end"] = end
                data[f"{i}{j}"]["shape"] = f"{i}_{j}.png"

        except FileNotFoundError:
            data[f"{i}{j}"]["energy"] = 0
            data[f"{i}{j}"]["letter"] = None
            data[f"{i}{j}"]["max"] = 0
            data[f"{i}{j}"]["index_app"] = 0
            data[f"{i}{j}"]["index_ct"] = 0
            data[f"{i}{j}"]["end"] = 0
            data[f"{i}{j}"]["shape"] = None
            pass

    df = pd.DataFrame.from_dict(data)
    self.thief = df


def intermediate_process(self):
    """
    This function is used to manipulate the dataframe generated by find_thief() and highlights the specific fields that are responsable for
    the energy loss.

    Args:
            self.thief : Dataframe containing the data generated by Mfold regarding the specific regions responsable for the energy loss
            self.strand : Structure class used to define the strand sequences
            self.regions : Region class used to define the regions provided
            self.header : Region identifiers provided by the user in user_input()
            self.index : Indices of the fields of interest
            self.highlighted : Fields of interest to be highlighted
            self.field : Fields generated by the user in user_input()
    """
    transposed = self.thief.transpose()

    for a, temp in enumerate(transposed["energy"]):
        header = []
        if temp == transposed["energy"].max():
            end = transposed["end"][a]
            atindex = transposed["index_app"][a]

            length = len(
                self.strand[
                    int(transposed["shape"][a].replace(".png", "").split("_")[0])
                ].bases
            )
            if transposed["end"][a] - 1 <= length:
                strand1 = int(transposed["shape"][a].replace(".png", "").split("_")[0])
            else:
                strand1 = int(transposed["shape"][a].replace(".png", "").split("_")[1])
                end = end - len(
                    self.strand[
                        int(transposed["shape"][a].replace(".png", "").split("_")[0])
                    ].bases
                )
                atindex = atindex - len(
                    self.strand[
                        int(transposed["shape"][a].replace(".png", "").split("_")[0])
                    ].bases
                )

            for b in range(len(self.regions[strand1].split("--"))):
                header.append(self.regions[strand1].split("--")[b])

            # flag = False
            # for _ in header:
            #     if (
            #         _ in self.fixed_regions.keys()
            #         or _.swapcase() in self.fixed_regions.keys()
            #     ):
            #         for i in range(len(self.thief.columns)):
            #             if (
            #                 self.thief.loc["energy"][i] == temp
            #                 and self.thief.loc["shape"][i] == transposed["shape"][a]
            #             ):
            #                 text = self.thief.columns.values.tolist()
            #                 self.thief = self.thief.drop(labels=[text[i]], axis=1)
            #                 flag = True
            #                 break
            #         break

            # if flag:
            #     break

            data = gc_content([], self)
            length = [len(data[header[_]]) for _ in range(len(header))]

            for c in range(len(header)):
                _ = 0
                while header[c] != self.header[_]:
                    _ += 1
                self.index.append(_)

            text = self.strand[strand1].bases

            if atindex > end:
                highlighted = str(f"{text[:atindex-1]}[{text[atindex-1:]}]")
            if atindex == end:
                highlighted = str(
                    f"{text[:atindex-1]}[{text[atindex-1:end]}]{text[end:]}"
                )
            else:
                highlighted = str(
                    f"{text[:atindex-1]}[{text[atindex-1:end-1]}]{text[end-1:]}"
                )

            tools = []
            flag = False

            for counter in range(len(length)):
                if flag:
                    if "]" in highlighted[: length[counter] + 2]:
                        tools.append(highlighted[: length[counter] + 2])
                        highlighted = highlighted[length[counter] + 2 :]
                        flag = False

                    else:
                        tools.append(highlighted[: length[counter] + 1])
                        highlighted = highlighted[length[counter] + 1 :]

                if "[" in highlighted[: length[counter] + 1]:
                    extra = highlighted[: length[counter] + 1]
                    if "]" in highlighted[: length[counter] + 2]:
                        tools.append(highlighted[: length[counter] + 2])
                        highlighted = highlighted[length[counter] + 2 :]
                        flag = False

                    if "[" == extra[-1]:
                        tools.append(highlighted[: length[counter]])
                        highlighted = highlighted[length[counter] :]
                        flag = True

                    else:
                        tools.append(highlighted[: length[counter] + 1])
                        highlighted = highlighted[length[counter] + 1 :]
                        flag = True

                else:
                    tools.append(highlighted[: length[counter]])
                    highlighted = highlighted[length[counter] :]

            if highlighted == "]":
                tools[-1] = tools[-1] + "]"
            while tools[-1] == "":
                tools.pop()

            self.highlighted = self.highlighted + tools
            tools = self.highlighted + tools

            counter = len(self.highlighted) - 1
            while counter >= 0:
                if "[" in self.highlighted[counter] or "]" in self.highlighted[counter]:
                    counter -= 1
                    continue
                tools.pop(counter)
                self.index.pop(counter)
                self.highlighted.pop(counter)
                counter -= 1

            counter = len(self.highlighted) - 1
            while counter >= 0:
                if self.highlighted.count(self.highlighted[counter]) > 1:
                    indices = [
                        i
                        for i, x in enumerate(self.highlighted)
                        if x == self.highlighted[counter]
                    ]
                    while len(indices) > 1:
                        self.highlighted.pop(indices[-1])
                        self.index.pop(indices[-1])
                        indices.pop(-1)
                        counter -= 1
                else:
                    counter -= 1

            for i in range(len(self.thief.columns)):
                if (
                    self.thief.loc["energy"][i] == temp
                    and self.thief.loc["shape"][i] == transposed["shape"][a]
                ):
                    self.shape.append(transposed["shape"][a])
                    text = self.thief.columns.values.tolist()
                    self.thief = self.thief.drop(labels=[text[i]], axis=1)
                    break


def gc_content(gc, self):
    """
    This function is used to measure the occurences of Gs or Cs in a given strand and also helps delimit and call specific region identifiers.

    Args:
            self.strand : Structure class used to define the strand sequences
            self.population_size : Length of a given region provided by the user in user_input()
            self.header : Region identifiers provided by the user in user_input()
            gc : an empty list to store the gc content measured by this function

    Returns:
            data : a dictionary containing region identifiers as keys and their respective sequences as items
            gc : gc content measured throughout each sequence(# of Gs and # of Cs)
    """
    gc.clear()
    gci = 0
    struct = {}
    temp = []
    test = []
    counter = 0
    for i in range(len(self.strand)):
        temp.append(self.strand[i].bases)

    full_sequence = "".join(temp)

    for i in self.regions:
        test += i.split("--")

    for i in range(len(self.header)):
        struct[self.header[i]] = self.population_size[i]

    counter = 0
    temp.clear()
    index = 0
    while counter < len(full_sequence):
        temp.append(full_sequence[counter : counter + struct[test[index]]])
        counter += struct[test[index]]
        index += 1

    data = dict()
    for m in range(len(test)):
        data[test[m]] = temp[m]

    for j, k in data.items():
        # for _ in k:
        #     if _ == "C" or _ == "G":
        #         gci += 1
        gci += k.count("G")
        gci += k.count("C")
        gc.append(gci)
        gci = 0

    return data


class GC_range_picker(QMainWindow):
    """
    This class creates a widget to provide the user with a range picker for a specific GC content range during the randomization process
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def input(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("GC content range picker")
        self.main_layout = QTabWidget()
        self.main_layout.setFixedSize(350, 200)

        self.vbox = QVBoxLayout()
        self.hbox = QHBoxLayout()
        self.slider1 = QSlider()
        self.slider1.setValue(int(self.parent().gc_min * 100))
        self.slider1.setMinimum(0)
        self.slider1.setMaximum(50)
        self.slider1.setTickInterval(10)
        self.slider1.setOrientation(Qt.Horizontal)
        self.slider1.valueChanged.connect(self.on_change_1)

        self.slider2 = QSlider()
        self.slider2.setValue(int(self.parent().gc_max * 100))
        self.slider2.setMinimum(50)
        self.slider2.setMaximum(100)
        self.slider2.setTickInterval(10)
        self.slider2.setOrientation(Qt.Horizontal)
        self.slider2.valueChanged.connect(self.on_change_2)

        self.label1 = QLabel(f"min : {self.slider1.value()}")
        self.label2 = QLabel(f"max : {self.slider2.value()}")
        self.yes = QPushButton("Confirm")

        self.yes.clicked.connect(self.close)
        self.yes.clicked.connect(self.parent().run_randomization)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.label1)
        hbox1.addWidget(self.label2)

        self.vbox.addWidget(
            QLabel(
                "Do you want to randomize the highlighted"
                + "\n"
                + "sequences with the following GC content range ?"
            )
        )
        self.vbox.addLayout(hbox1)
        self.hbox.addWidget(self.slider1)
        self.hbox.addWidget(self.slider2)
        self.vbox.addLayout(self.hbox)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)
        self.setFixedSize(350, 200)
        self.move(600, 350)

        self.show()

    def on_change_1(self):
        """
        This event handler is called when the minimun value is picked from the range picker
        """
        self.label1.setText(f"min : {self.slider1.value()}")
        self.parent().gc_min = self.slider1.value() / 100

    def on_change_2(self):
        """
        This event handler is called when the maximum value is picked from the range picker
        """
        self.label2.setText(f"max : {self.slider2.value()}")
        self.parent().gc_max = self.slider2.value() / 10


class Loop_input_widget(QMainWindow):
    """
    This class creates a widget to provide the user with a range picker for a specific GC content range during the loop calculation process and specifies the number of iterations
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def input(self):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Iterations required")
        self.main_layout = QTabWidget()
        self.main_layout.setFixedSize(350, 200)

        self.field = QLineEdit()
        self.vbox = QVBoxLayout()
        self.hbox = QHBoxLayout()
        self.slider1 = QSlider()
        self.slider1.setValue(40)
        self.slider1.setMinimum(0)
        self.slider1.setMaximum(50)
        self.slider1.setTickInterval(10)
        self.slider1.setOrientation(Qt.Horizontal)
        self.slider1.valueChanged.connect(self.on_change_1)

        self.slider2 = QSlider()
        self.slider2.setValue(60)
        self.slider2.setMinimum(50)
        self.slider2.setMaximum(100)
        self.slider2.setTickInterval(10)
        self.slider2.setOrientation(Qt.Horizontal)
        self.slider2.valueChanged.connect(self.on_change_2)
        self.field.editingFinished.connect(self.on_change)

        self.label1 = QLabel(f"min : {self.slider1.value()}")
        self.label2 = QLabel(f"max : {self.slider2.value()}")
        self.yes = QPushButton("Confirm")

        self.yes.clicked.connect(self.close)
        self.yes.clicked.connect(self.parent().run_loop)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.label1)
        hbox1.addWidget(self.label2)

        self.vbox.addWidget(QLabel("Please provide the number of iterations"))
        self.vbox.addWidget(self.field)
        self.vbox.addLayout(hbox1)
        self.hbox.addWidget(self.slider1)
        self.hbox.addWidget(self.slider2)
        self.vbox.addLayout(self.hbox)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)
        self.setCentralWidget(self.main_layout)
        self.setFixedSize(350, 200)
        self.move(600, 350)

        self.show()

    def on_change(self):
        """
        This event handler is called when the number of iterations is provided and validates the input
        """
        try:
            self.parent().iterator = int(self.field.text())
        except ValueError:
            error = QErrorMessage(self)
            error.showMessage(
                f"Please make sure to provide an integer value greater than 0"
            )

    def on_change_1(self):
        """
        This event handler is called when the minimum value is picked from the range picker
        """
        self.label1.setText(f"min : {self.slider1.value()}")
        self.parent().gc_min = self.slider1.value() / 100

    def on_change_2(self):
        """
        This event handler is called when the maximum value is picked from the range picker
        """
        self.label2.setText(f"max : {self.slider2.value()}")
        self.parent().gc_max = self.slider2.value() / 100


class Export_message(QMainWindow):
    def _init_(self, main):
        super().__init__()
        self.parent = main

    def export(self):
        self.setWindowTitle("Save current configuration")
        self.main_layout = QWidget()
        # self.main_layout.setFixedSize(700, 500)

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.vbox = QVBoxLayout()
        self._vbox = QVBoxLayout()
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self._vbox)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)

        self.yes = QPushButton("Confirm")
        self.yes.clicked.connect(self.save_configuration)

        strand = ""
        data = gc_content([], self.parent())
        ticks = self.parent().regions
        for i in range(len(self.parent().strand)):
            j = len(ticks[i].split("--"))
            for _ in range(j):
                if _ == 0:
                    strand = str(data[ticks[i].split("--")[_]])
                else:
                    strand += "--" + str(data[ticks[i].split("--")[_]])

            row = QLabel(f"{ticks[i]}: {strand}")
            self._vbox.addWidget(row)

        self.vbox.addWidget(self.scroll)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)

        self.setCentralWidget(self.main_layout)
        self.move(300, 150)
        self.main_layout.adjustSize()
        self.show()

    def save_configuration(self):
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            params = {}

            data = gc_content([], self.parent())
            for i in range(len(self.parent().header)):
                self.parent().input_sequence[self.parent().header[i]] = data[
                    self.parent().header[i]
                ]

            params["raw_structure"] = self.parent().raw_structure
            params["mfold_command"] = "./mfold_quik"
            params["boltzmann_factor"] = 1
            params["fixed_regions"] = self.parent().fixed_regions
            params["input_sequence_definitions"] = self.parent().input_sequence
            params["energy_matrix"] = self.parent().energy
            try:
                with open(str(filename[0] + ".dat"), "w") as configfile:
                    yaml.dump(params, configfile)
            except FileNotFoundError:
                pass
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")


class Export_oligos_message(QMainWindow):
    def _init_(self, main):
        super().__init__()
        self.parent = main

    def export(self):
        self.setWindowTitle("Save current oligos")
        self.main_layout = QWidget()

        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("border: none")
        self.vbox = QVBoxLayout()
        self._vbox = QVBoxLayout()
        self.mygroup = QGroupBox()
        self.mygroup.setStyleSheet("border: none")
        self.mygroup.setLayout(self._vbox)
        self.scroll.setWidget(self.mygroup)
        self.scroll.setWidgetResizable(True)

        self.yes = QPushButton("Confirm")
        self.yes.clicked.connect(self.save_configuration)

        for i in range(len(self.parent().regions)):
            row = QLabel(f"{self.parent().regions[i]}: {self.parent().strand[i].bases}")
            self._vbox.addWidget(row)

        self.vbox.addWidget(self.scroll)
        self.vbox.addWidget(self.yes)

        self.main_layout.setLayout(self.vbox)

        self.setCentralWidget(self.main_layout)
        self.move(300, 150)
        self.main_layout.adjustSize()
        self.show()

    def save_configuration(self):
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "",
        )

        if str(filename[0]) != "":
            try:
                message = {}
                for i in range(len(self.parent().regions)):
                    message[self.parent().regions[i]] = self.parent().strand[i].bases

                export = {}
                with open(str(filename[0] + ".dat"), "w") as configfile:
                    for key, value in message.items():
                        key = key.replace("--", "")
                        export[key] = value

                    yaml.dump(export, configfile)
            except FileNotFoundError:
                pass
            self.close()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a name for this file")


class Paint_structure(QMainWindow):
    """
    This class creates a widget to provide the user with a structure viewer to visualize the sequence's binding
    """

    def _init_(self, main):
        super().__init__()
        self.parent = main

    def paint(self, x, y):
        """
        Initialization of the widget and event binding
        """
        self.setWindowTitle("Structure viewer")
        self._zoom = 0
        self.tabs = QTabWidget()
        self.tabs.setFixedSize(1200, 700)

        cwd = os.getcwd()
        test = os.listdir(cwd)

        for item in test:
            if item.endswith(f"{y}_{x}.png"):
                e = f"{y}_{x}.png"

                label = QLabel(
                    f"This is the interaction between {self.parent().regions[y]} (from 1 to {len(self.parent().strand[y].bases) + 1}) and {self.parent().regions[x]} (from {len(self.parent().strand[y].bases) + 1} to {len(self.parent().strand[y].bases) + len(self.parent().strand[x].bases)})({e})"
                )

                pixmap = QPixmap(e)
                item = QGraphicsPixmapItem(pixmap)
                scene = QGraphicsScene(self)
                scene.addItem(item)
                self.view = QGraphicsView()
                self.view.setScene(scene)

                tab = QWidget()
                tab.layout = QVBoxLayout()
                tab.layout.addWidget(label)
                tab.layout.addWidget(self.view)
                tab.setLayout(tab.layout)
                self.tabs.addTab(
                    tab, f"{self.parent().regions[y]} and {self.parent().regions[x]}"
                )

                self.setCentralWidget(self.tabs)

                self.setFixedSize(1200, 700)
                self.move(100, 100)
                self.show()
                break

    def keyPressEvent(self, event):
        """
        Allowing zooming capabilites for the structure viewer
        """
        if event.key() == 43:  #  or "+" key
            self._zoom = 1.25
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 45:  #  or "-" key
            self._zoom = 0.8
            self.view.scale(self._zoom, self._zoom)
        elif event.key() == 72:  #  or "h" key
            self.view.fitInView(self.view.sceneRect(), Qt.KeepAspectRatio)


class DNA_origami(QWidget):
    """
    This class creates the main widget for this application
    """

    def __init__(self):
        super().__init__()
        self.header = []
        self.check = []
        self.fixed_regions = {}
        self.label = []
        self.regions = []
        self.population_size = []
        self.index = []
        self.input_sequence = {}
        self.field = []
        self.raw_structure = None
        self.automate = False
        self.iterator = 0
        self.file_counter = 0
        self.thief = None
        self.gc_max = 0.6
        self.gc_min = 0.4
        self.strand = []
        self.shape = []
        self.highlighted = []
        self.energy = []
        self.max = 0
        self.initUI()

    def initUI(self):
        """
        This function defines the display of the main widget and event bindings
        """
        self.btn1 = QPushButton("Specify Structure")
        self.btn1.setFixedSize(150, 70)
        self.btn1.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn1.clicked.connect(self.user_input)
        self.btn2 = QPushButton("Maximum Energy")
        self.btn2.setFixedSize(150, 70)
        self.btn2.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn2.clicked.connect(self.user_max)
        self.btn3 = QPushButton("Calculate" + "\n" + "energy")
        self.btn3.setFixedSize(150, 70)
        self.btn3.setIcon(QIcon("assets/sync-solid.svg"))
        self.btn3.setIconSize(QSize(30, 30))
        self.btn3.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn3.clicked.connect(self.calculate)
        self.btn4 = QPushButton("View/Save" + "\n" + "configuration")
        self.btn4.setFixedSize(150, 70)
        self.btn4.setIcon(QIcon("assets/download-solid.svg"))
        self.btn4.setIconSize(QSize(30, 30))
        self.btn4.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn4.clicked.connect(self.export)
        self.btn5 = QPushButton("Load" + "\n" + "configuration")
        self.btn5.setFixedSize(150, 70)
        self.btn5.setIcon(QIcon("assets/upload-solid.svg"))
        self.btn5.setIconSize(QSize(30, 30))
        self.btn5.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn7 = QPushButton()
        self.btn7.setFixedSize(40, 40)
        self.btn7.setToolTip("Export data")
        self.btn7.setIcon(QIcon("assets/save-solid.svg"))
        self.btn7.setIconSize(QSize(20, 20))
        self.btn7.setStyleSheet(
            "QPushButton {border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn8 = QPushButton("Optimize")
        self.btn8.setFixedSize(150, 70)
        self.btn8.setIconSize(QSize(30, 30))
        self.btn8.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn9 = QPushButton("Calculate" + "\n" + " + " + "\n" + "Optimize")
        self.btn9.setFixedSize(150, 70)
        self.btn9.setIconSize(QSize(30, 30))
        self.btn9.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn10 = QPushButton("Show structure")
        self.btn10.setFixedSize(150, 70)
        self.btn10.setIconSize(QSize(30, 30))
        self.btn10.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn11 = QPushButton("Export oligos")
        self.btn11.setFixedSize(150, 70)
        self.btn11.setIcon(QIcon("assets/download-solid.svg"))
        self.btn11.setIconSize(QSize(30, 30))
        self.btn11.setStyleSheet(
            "QPushButton {background-color: #007bff; color: white; border: 5px solid transparent; border-radius: 5px}"
        )
        self.btn5.clicked.connect(self.load)
        self.btn7.clicked.connect(self.output_data)
        self.btn8.clicked.connect(self.randomize_strand)
        self.btn9.clicked.connect(self.loop_calculation)
        self.btn10.clicked.connect(self.display_structure)
        self.btn11.clicked.connect(self.export_oligos)

        self.tabs = QTabWidget()
        self.tabs.setFixedSize(500, 570)

        self.canvas = FigureCanvas(
            plt.Figure(dpi=100, tight_layout=True, frameon=False)
        )
        self.canvas.setFixedSize(490, 450)
        toolbar = NavigationToolbar2QT(self.canvas, self)
        horizontal_toolbar = QHBoxLayout()
        horizontal_toolbar.addWidget(self.btn7)
        horizontal_toolbar.addWidget(toolbar)
        self.tab1 = QWidget()
        self.tabs.addTab(self.tab1, "Energy")

        self.tab1.layout = QVBoxLayout()
        self.tab1.layout.addWidget(QLabel("Energy matrix for region interaction"))
        self.tab1.layout.addWidget(self.canvas)
        self.tab1.layout.addLayout(horizontal_toolbar)
        self.tab1.setLayout(self.tab1.layout)
        self.canvas.mpl_connect("button_press_event", self.render_structure)

        main_layout = QHBoxLayout()

        temp_bottom = QHBoxLayout()
        self.top_layout = QHBoxLayout()
        self.top_layout.setSpacing(30)
        self.center_layout = QFormLayout()
        self.bottom_layout = QHBoxLayout()
        temp_vertical = QVBoxLayout()
        self.bottom_layout.setSpacing(30)
        self.right_side = QVBoxLayout()
        self.left_side = QVBoxLayout()
        self.top_layout.addWidget(self.btn1)
        self.top_layout.addWidget(self.btn10)
        self.top_layout.addWidget(self.btn2)
        temp_vertical.addWidget(self.btn8)
        temp_vertical.addWidget(self.btn9)
        self.bottom_layout.addLayout(temp_vertical)
        self.bottom_layout.addWidget(self.btn3)
        temp_export = QVBoxLayout()
        temp_export.addWidget(self.btn4)
        temp_export.addWidget(self.btn11)
        self.bottom_layout.addLayout(temp_export)
        self.bottom_layout.addWidget(self.btn5)
        self.left_side.addLayout(self.top_layout)

        self.scroll_1 = QScrollArea()
        self.scroll_1.setStyleSheet("border: none")
        self.mygroup_1 = QGroupBox()
        self.mygroup_1.setStyleSheet("border: none")
        self.mygroup_1.setLayout(self.center_layout)
        self.scroll_1.setWidget(self.mygroup_1)
        self.scroll_1.setWidgetResizable(True)
        self.left_side.addWidget(self.scroll_1)
        self.left_side.addLayout(self.bottom_layout)

        self.right_side.addWidget(self.tabs)
        self.progress = QProgressBar()
        self.progress.setAlignment(Qt.AlignHCenter)
        self.progress.setFixedSize(350, 30)
        temp_bottom.addWidget(self.progress)

        self.right_side.addLayout(temp_bottom)
        main_layout.addLayout(self.left_side)
        main_layout.addLayout(self.right_side)
        self.setLayout(main_layout)
        self.setWindowTitle("DNA origami")
        self.move(100, 100)
        self.setFixedSize(1200, 700)
        self.show()

    def user_input(self):
        """
        This function is used to take the user input and send it to render_form() to create the form layout for the input provided.

        Args:
                self.raw_structure : The raw input as inputed by the user from user_input()
        """
        input = QInputDialog()
        text, ok = input.getText(
            self,
            "Input Shape",
            "Enter your desired shape (for example: a25 B25, b25 C25, c25 D25, d25 A25)",
        )

        if ok:
            if str(text) != "":
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)

                self.header.clear()
                self.field.clear()
                self.label.clear()
                self.check.clear()
                self.regions.clear()
                self.fixed_regions = {}
                self.strand.clear()
                self.energy.clear()
                self.population_size.clear()
                self.input_sequence = {}

                try:
                    self.raw_structure = text
                    self.render_form()
                except (KeyError, IndexError):
                    error = QErrorMessage(self)
                    error.showMessage("Please follow the given structure format")

    def render_form(self):
        """
        This function is used to process the input provided by the user and render a form layout containing a header as the region identifier,
        the population size, its GC content, a random sequence generated for this region identifier and a checkbox if this region can be modified.

        Args:
                self.regions : Regions by the user in user_input()
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.input_sequences : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
        """
        self.regions.clear()
        self.header.clear()
        gc = []

        structure = [
            [
                Region(
                    re.findall("\D+", region)[0],
                    int(re.findall("\d+", region)[0]),
                )
                for region in strand
            ]
            for strand in [
                strand.strip().split() for strand in self.raw_structure.split(",")
            ]
        ]

        temp = []

        for i, struct in enumerate(structure):
            region = ""
            for j in range(len(struct)):
                if not str(struct[j]).split("'")[1] in self.header:
                    self.header.append(str(struct[j]).split("'")[1])
                    temp.append(int(str(struct[j]).split(" ")[1].split(")")[0]))

                if j == 0:
                    region += str(struct[j]).split("'")[1]
                else:
                    region += "--" + str(struct[j]).split("'")[1]
            self.regions.append(region)
        self.population_size = temp

        sequence = Sequence.random_sequence(structure, self.fixed_regions)
        self.strand = [
            sequence.build_strand(test) for test in sequence.strand_structures
        ]

        if self.input_sequence != {}:
            bases = ""
            for i, region in enumerate(self.regions):
                for _ in region.split("--"):
                    bases += str(self.input_sequence[_])

                self.strand[i].bases = bases
                bases = ""

        counter = 0
        for i in range(len(self.strand)):
            temp = self.strand[i].bases
            while temp.find("AAAAAAAAAA") != -1:
                counter = temp.index("AAAAAAAAAA")
                temp = temp[:counter] + "T" + temp[counter + 1 :]
            while temp.find("TTTTTTTTTT") != -1:
                counter = temp.index("TTTTTTTTTT")
                temp = temp[:counter] + "A" + temp[counter + 1 :]
            while temp.find("CCCCCC") != -1:
                counter = temp.index("CCCCCC")
                temp = temp[:counter] + "G" + temp[counter + 1 :]
            while temp.find("GGGGGG") != -1:
                counter = temp.index("GGGGGG")
                temp = temp[:counter] + "C" + temp[counter + 1 :]
            self.strand[i].bases = temp

        data = gc_content(gc, self)

        for i, header in enumerate(self.header):
            self.label.append(
                QLabel(
                    header
                    + f" {self.population_size[i]} (GC count: "
                    + str(gc[i])
                    + ") "
                )
            )
            self.label[i].setFixedSize(170, 30)
            self.check.append(QCheckBox("Set as fixed region"))

            if header.islower():
                if header in self.fixed_regions.keys():
                    self.field.append(QLineEdit(data[header]))
                    self.check[i].setChecked(True)
                    self.field[i].setEnabled(False)
                    self.field[i].setMaxLength(self.population_size[i])
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[i].setValidator(validator)
                    horizontal = QHBoxLayout()
                    horizontal.addWidget(self.field[i])
                    horizontal.addWidget(self.check[i])
                else:
                    self.field.append(QLineEdit(data[header]))
                    self.field[i].setMaxLength(self.population_size[i])
                    regex = QRegExp("[ACGT]+")
                    validator = QRegExpValidator(regex)
                    self.field[i].setValidator(validator)
                    horizontal = QHBoxLayout()
                    horizontal.addWidget(self.field[i])
                    horizontal.addWidget(self.check[i])
            else:
                self.field.append(QLineEdit(data[header]))
                self.field[i].setEnabled(False)
                horizontal = QHBoxLayout()
                horizontal.addWidget(self.field[i])

            self.field[i].setFixedSize(300, 30)
            self.center_layout.addRow(self.label[i], horizontal)
            self.field[i].editingFinished.connect(self.strand_update)
            self.check[i].stateChanged.connect(self.set_fixed)

    def strand_update(self):
        """
        This function is used to fire after the user updates a sequence in the user fields and performs the modifications in the strand variable.

        Args:
                self.field : Fields generated by the user in user_input()
                self.population_size : Length of a given region provided by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
                self.label : A text box containing a region identifier with its respective gc content
        """
        for i, field in enumerate(self.field):
            field.setStyleSheet("background-color: white")
            if field.isModified():
                text = field.text()

                if len(text) != self.population_size[i]:
                    data = gc_content([], self)
                    field.setText(data[self.header[i]])

                else:
                    maj = text.upper()
                    maj = maj[::-1]

                    temp = (
                        maj.replace("A", "temp").replace("T", "A").replace("temp", "T")
                    )
                    temp = (
                        temp.replace("C", "temp").replace("G", "C").replace("temp", "G")
                    )

                    data = gc_content([], self)
                    if self.header[i].islower():
                        for j, strand in enumerate(self.strand):
                            if data[self.header[i].lower()] in strand.bases:
                                old = strand.bases
                                update = old.replace(data[self.header[i]], text)
                                strand.bases = update

                            if self.header[i].upper() in data.keys():
                                if data[self.header[i].upper()] in strand.bases:
                                    old = strand.bases
                                    update = old.replace(
                                        data[self.header[i].upper()], temp
                                    )
                                    strand.bases = update

                    if self.header[i].isupper():
                        for j, strand in enumerate(self.strand):
                            if data[self.header[i].lower()] in strand.bases:
                                old = strand.bases
                                update = old.replace(data[self.header[i].lower()], temp)
                                strand.bases = update

                            if self.header[i].upper() in data.keys():
                                if data[self.header[i].upper()] in strand.bases:
                                    old = strand.bases
                                    update = old.replace(
                                        data[self.header[i].upper()], text
                                    )
                                    strand.bases = update

                    gc = []
                    new = gc_content(gc, self)
                    self.label[i].setText(
                        self.header[i]
                        + f" {self.population_size[i]} (GC count: "
                        + str(gc[i])
                        + ") "
                    )

                    for a, b in new.items():
                        if b != data[a]:
                            for c, header in enumerate(self.header):
                                if a == header:
                                    self.label[c].setText(
                                        a
                                        + f" {self.population_size[i]} (GC count: "
                                        + str(gc[i])
                                        + ") "
                                    )
                                    self.field[c].setText(b)

    def set_fixed(self):
        """
        This function is used to define fixed regions by the user and store them in a dictionary variable.

        Args:
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.field : Fields generated by the user in user_input()
                self.header : Region identifiers provided by the user in user_input()
        """
        self.fixed_regions = {}
        for i, check in enumerate(self.check):
            if check.isChecked() == True:
                self.field[i].setEnabled(False)
                data = gc_content([], self)
                self.fixed_regions[self.header[i]] = data[self.header[i]]
                self.fixed_regions[self.header[i].upper()] = data[
                    self.header[i].upper()
                ]
            if check.isChecked() == False:
                if self.header[i].islower():
                    self.field[i].setEnabled(True)

    def user_max(self):
        """
        This function is used to specify the max value that is shown in the heatmap and is defined by the user with a validation step.

        Args:
                self.max : A value set by the user to rescale the heatmap max value
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        energy = QInputDialog()
        text, ok = energy.getText(
            self, "Maximum Energy", "Enter the maximum energy value for this shape:"
        )
        if ok:
            if str(text) != "":
                if float(text) >= 0:
                    self.max = float(text)
                    if self.energy != 0:
                        minimum = []
                        for i in range(len(self.energy)):
                            temp = min(self.energy[i])
                            minimum.append(temp)

                        if self.max > min(minimum):
                            self.update()
                        else:
                            error = QErrorMessage(self)
                            error.showMessage(
                                "This value is less than the minimum possible value"
                            )

                else:
                    error = QErrorMessage(self)
                    error.showMessage("Please give a positive value")

    def export_oligos(self):
        message = {}
        for _ in range(len(self.regions)):
            message[self.regions[_]] = self.strand[_].bases

        if message != {}:
            window = Export_oligos_message(self)
            window.export()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a configuration")

        # message = {}
        # for _ in range(len(self.regions)):
        #     message[self.regions[_]] = self.strand[_].bases

        # window = QMessageBox()
        # reply = window.question(
        #     self,
        #     "Current strand/save current configuration",
        #     "The current strand configuration is "
        #     + "\n"
        #     + str(json.dumps(message, indent=4))
        #     + "\n"
        #     + "Do you want to save this configuration ?",
        #     QMessageBox.Yes | QMessageBox.No,
        #     0,
        # )
        # QMessageBox.adjustSize(self)

        # if reply == QMessageBox.Yes:
        #     filename = QFileDialog.getSaveFileName(
        #         self,
        #         "Save configuration",
        #         "/bureau/dna-origami",
        #     )

        #     try:
        #         export = {}
        #         with open(str(filename[0] + ".dat"), "w") as configfile:
        #             for key, value in message.items():
        #                 key = key.replace("--", "")
        #                 export[key] = value

        #             yaml.dump(export, configfile)
        #     except FileNotFoundError:
        #         pass
        # else:
        #     pass

    def export(self):
        """
        This function is used to export the current configuration and respects the upload format required by the application.

        Args:
                self.regions : Regions provided by the user in user_input()
                self.strand : Structure class used to define the strand sequences
                self.header : Region identifiers provided by the user in user_input()
                self.input_sequence : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        message = {}
        data = gc_content([], self)
        ticks = self.regions
        for i in range(len(self.strand)):
            j = len(ticks[i].split("--"))
            for _ in range(j):
                if _ == 0:
                    message[ticks[i]] = str(data[ticks[i].split("--")[_]])
                else:
                    message[ticks[i]] += "--" + str(data[ticks[i].split("--")[_]])

        if message != {}:
            window = Export_message(self)
            window.export()
        else:
            error = QErrorMessage(self)
            error.showMessage("Please provide a configuration")

        # message = {}
        # data = gc_content([], self)
        # ticks = self.regions
        # for i in range(len(self.strand)):
        #     j = len(ticks[i].split("--"))
        #     for _ in range(j):
        #         if _ == 0:
        #             message[ticks[i]] = str(data[ticks[i].split("--")[_]])
        #         else:
        #             message[ticks[i]] += "--" + str(data[ticks[i].split("--")[_]])

        # window = QMessageBox()
        # reply = window.question(
        #     self,
        #     "Current strand/save current configuration",
        #     "The current strand configuration is "
        #     + "\n"
        #     + str(json.dumps(message, indent=4))
        #     + "\n"
        #     + "Do you want to save this configuration ?",
        #     QMessageBox.Yes | QMessageBox.No,
        #     0,
        # )
        # QMessageBox.adjustSize(self)

        # if reply == QMessageBox.Yes:
        #     filename = QFileDialog.getSaveFileName(
        #         self,
        #         "Save configuration",
        #         "/bureau/dna-origami",
        #     )
        #     params = {}

        #     data = gc_content([], self)
        #     for i in range(len(self.header)):
        #         self.input_sequence[self.header[i]] = data[self.header[i]]

        #     params["raw_structure"] = self.raw_structure
        #     params["mfold_command"] = "./mfold_quik"
        #     params["boltzmann_factor"] = 1
        #     params["fixed_regions"] = self.fixed_regions
        #     params["input_sequence_definitions"] = self.input_sequence
        #     params["energy_matrix"] = self.energy
        #     try:
        #         with open(str(filename[0] + ".dat"), "w") as configfile:
        #             yaml.dump(params, configfile)
        #     except FileNotFoundError:
        #         pass
        # else:
        #     pass

    def display_structure(self):
        window = QMessageBox()
        reply = window.question(
            self,
            "Current structure is",
            str(self.raw_structure),
            QMessageBox.Close,
            0,
        )

    def load(self):
        """
        This function is responsable for the upload fonctionality of the application and takes in a ".dat" file structured as the export format defined.

        Args:
                self.header : Region identifiers provided by the user in user_input()
                self.field : Fields generated by the user in user_input()
                self.label : A text box containing a region identifier with its respective gc content
                self.check : A checkbox to manipulate the status of region identifiers (fixed or modifiable)
                self.regions : Regions provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.strand : Structure class used to define the strand sequences
                self.population_size : Length of a given region provided by the user in user_input()
                self.input_sequence : The randomnly generated sequences from the class Sequence and save for prospective usages
                self.raw_structure : The raw input as inputed by the user from user_input()
                self.energy : Matrix used to store the energy loss returned by the Mfold program
        """
        filename = QFileDialog.getOpenFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if not filename[0].endswith(".dat"):
                error = QErrorMessage(self)
                error.showMessage("Please upload a file with .dat extension")
            else:
                try:
                    while self.center_layout.count() != 0:
                        self.center_layout.removeRow(0)

                    self.header.clear()
                    self.field.clear()
                    self.label.clear()
                    self.check.clear()
                    self.regions.clear()
                    self.fixed_regions = {}
                    self.highlighted.clear()
                    self.index.clear()
                    self.strand.clear()
                    self.population_size.clear()
                    self.input_sequence = {}
                    with open(filename[0], "r") as configfile:
                        params = yaml.load(configfile, Loader=yaml.FullLoader)
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions = params["fixed_regions"]
                        self.input_sequence = params["input_sequence_definitions"]
                        self.render_form()
                        self.update()

                except FileNotFoundError:
                    pass
                except TypeError:
                    error = QErrorMessage(self)
                    error.showMessage("Please upload a file with .dat extension")
                except KeyError:
                    error = QErrorMessage(self)
                    error.showMessage("Please respect the configuration file format")

    def calculate(self):
        """
        This function is responsable for the call to Mfold software and stores the returned energy in a matrix variable.
        It also makes sure that the gc content boundaries are respected.

        Args:
                self.strand : Structure class used to define the strand sequences
                self.header : Region identifiers provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                        and associated sequence as item
                self.field : Fields generated by the user in user_input()
        """
        self.btn3.setEnabled(False)
        flag_range = False
        index = 0

        gc = []
        _ = {}

        try:
            _ = gc_content(gc, self)
        except IndexError:
            self.calculate()

        for j in range(len(gc)):
            if (gc[j] / self.population_size[j]) >= self.gc_min and (
                gc[j] / self.population_size[j]
            ) <= self.gc_max:
                flag_range = True
            else:
                index = j
                flag_range = False
                break

        if self.strand == []:
            error = QErrorMessage(self)
            error.showMessage("Please provide a structure")
            self.btn3.setEnabled(True)

        # elif self.header[index] in self.fixed_regions.keys():
        #     error = QErrorMessage(self)
        #     error.showMessage(
        #         f"Please make sure to uncheck the field {self.header[index].lower()} to allow modifications"
        #     )
        #     self.btn3.setEnabled(True)

        else:
            if flag_range:
                for i in range(len(self.field)):
                    self.field[i].setToolTip("")

                try:
                    self.run_calculation()
                    find_thief(self)
                    self.highlight_thief()
                    clear_files()
                    self.update()
                    self.progress.setFormat("DONE")
                    self.btn3.setEnabled(True)
                except StopIteration:
                    error = QErrorMessage(self)
                    message = list(self.fixed_regions.keys())
                    message = [x for x in message if x.islower()]
                    message = ", ".join(message)
                    error.showMessage(
                        f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                    )
                    self.progress.setFormat("DONE")
                    self.progress.setValue(100)
                    clear_files()
                    self.btn3.setEnabled(True)

            else:
                if gc[index] / self.population_size[index] < self.gc_min:
                    if self.header[index].islower():
                        temp = self.field[index].text()
                        previous = temp
                        text = temp.replace("A", "G", 1)
                        if previous == text:
                            text = temp.replace("T", "G", 1)
                        self.field[index].setText(text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                    else:
                        for j, header in enumerate(self.header):
                            if header.islower():
                                if header == self.header[index].lower():
                                    index = j
                        temp = self.field[index].text()
                        previous = temp
                        text = temp.replace("A", "G", 1)
                        if previous == text:
                            text = temp.replace("T", "G", 1)
                        self.field[index].setText(text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                if gc[index] / self.population_size[index] > self.gc_max:
                    if self.header[index].islower():
                        temp = self.field[index].text()
                        previous = temp
                        text = temp.replace("G", "A", 1)
                        if previous == text:
                            text = temp.replace("C", "A", 1)
                        self.field[index].setText(text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

                    else:
                        for j, header in enumerate(self.header):
                            if header.islower():
                                if header == self.header[index].lower():
                                    index = j
                        temp = self.field[index].text()
                        previous = temp
                        text = temp.replace("G", "A", 1)
                        if previous == text:
                            text = temp.replace("C", "A", 1)
                        self.field[index].setText(text)
                        self.field[index].setModified(True)
                        self.strand_update()
                        self.calculate()

    def run_calculation(self):
        """
        This function initiates the call to the mfold software and populates the energy matrix of the main class while updating the progress.

        Args:
                self.progress : Progress bar variable for live update on the main widget
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.strand : Structure class used to define the strand sequences
                self.region : Regions provided by the user in user_input()

        """
        mfold = Mfold(output_folder="./", mfold_command="mfold_quik")

        self.progress.setFormat("PROGRESSING")

        self.energy = [[None for strand1 in self.strand] for strand2 in self.strand]

        data = gc_content([], self)
        for i, strand1 in enumerate(self.strand):
            if not self.automate:
                self.progress.setValue(int((i / len(self.strand)) * 100))
            for j, strand2 in enumerate(self.strand):
                region1 = self.regions[i].split("--")
                region2 = self.regions[j].swapcase().split("--")
                region2 = region2[::-1]

                constraint = None
                if region1 == region2:
                    constraint = None

                else:
                    flag = False

                    if region1[-1] == region2[-1]:
                        flag = True

                    region1 = dict.fromkeys(region1)
                    region2 = dict.fromkeys(region2[::-1])
                    length = 1
                    for key in region1.keys():
                        region1[key] = f"{length}-{length + len(data[key]) - 1}"
                        length += len(data[key])

                    length += 3
                    for key in region2.keys():
                        region2[key] = f"{length}-{length + len(data[key]) - 1}"
                        length += len(data[key])

                    shared_list = [k for k in region1.keys() if k in region2.keys()]
                    complementary_1 = [
                        (k, k.swapcase())
                        for k in region1.keys()
                        if k.swapcase() in region1.keys()
                    ]
                    complementary_2 = [
                        (k, k.swapcase())
                        for k in region2.keys()
                        if k.swapcase() in region2.keys()
                    ]

                    if len(shared_list) < 2:
                        for key in shared_list:
                            if constraint is None:
                                constraint = f"P {region1[key]} {region2[key]}\n"
                                for value in complementary_1:
                                    constraint += (
                                        f"P {region1[value[0]]} {region1[value[1]]}\n"
                                    )
                                for value in complementary_2:
                                    constraint += (
                                        f"P {region2[value[0]]} {region2[value[1]]}\n"
                                    )
                            else:
                                constraint += f"P {region1[key]} {region2[key]}\n"
                                for value in complementary_1:
                                    constraint += (
                                        f"P {region1[value[0]]} {region1[value[1]]}\n"
                                    )
                                for value in complementary_2:
                                    constraint += (
                                        f"P {region2[value[0]]} {region2[value[1]]}\n"
                                    )
                    else:
                        if flag:
                            _min = region1[shared_list[0]].split("-")[0]
                            _max = region2[shared_list[0]].split("-")[1]
                            constraint = f"P {_min}-{_max} {_min}-{_max}\n"
                            for value in complementary_1:
                                constraint += (
                                    f"P {region1[value[0]]} {region1[value[1]]}\n"
                                )
                            for value in complementary_2:
                                constraint += (
                                    f"P {region2[value[0]]} {region2[value[1]]}\n"
                                )
                        else:
                            _min_i = region1[shared_list[0]].split("-")[0]
                            _max_i = region1[shared_list[-1]].split("-")[1]
                            _max_j = region2[shared_list[0]].split("-")[1]
                            _min_j = region2[shared_list[-1]].split("-")[0]
                            constraint = f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                            for value in complementary_1:
                                constraint += (
                                    f"P {region1[value[0]]} {region1[value[1]]}\n"
                                )
                            for value in complementary_2:
                                constraint += (
                                    f"P {region2[value[0]]} {region2[value[1]]}\n"
                                )

                mfold.run(strand1, strand2, constraint, f"{i}_{j}.seq", f"{i}_{j}.aux")
                with open(f"{i}_{j}.det", "r") as configfile:
                    for line in configfile:
                        if line.startswith(" dG = "):
                            self.energy[i][j] = abs(float(line[10:15]))
                            break

        if not self.automate:
            self.progress.setValue(100)

    def figure_generation(self):
        """
        This function is responsable for the structure viewer generated images.

        Args:
                self.shape : Indices to identify the interaction to be generated
                self.strand : Structure class used to define the strand sequences
                self.regions : Regions provided by the user in user_input()
        """
        for e in self.shape:
            _ = e.replace(".png", "").split("_")
            _ = [int(i) for i in _]
            with open(f"{_[0]}_{_[1]}.ct", "r") as configfile:
                counter = 0
                max = 0
                for line in configfile:
                    if line[7:8] == "d":
                        counter += 1
                        continue
                    if counter > (
                        len(self.strand[_[0]].bases) + len(self.strand[_[1]].bases) + 4
                    ):
                        break
                    if int(line[26:30]) > max:
                        max = int(line[26:30])
                    counter += 1

            with open(f"{_[0]}_{_[1]}.ct", "r") as configfile:
                nodes_list = []
                flag = False
                G = nx.MultiDiGraph()

                labels = {}
                text = ""
                counter = 0
                before = 0
                center = 0
                extra = 0
                for line in configfile:
                    if line[7:8] == "d":
                        exit = int(line[3:6])
                        continue

                    if line[7:8] == "L":
                        continue

                    if int(line[26:30]) == max:
                        flag = True

                    if counter < len(self.strand[_[0]].bases):
                        before = int(line[12:15])
                        center = int(line[3:6])
                        nodes_list.append(before)
                        G.add_edge(before, center, color="black", weight=100)

                        if counter == 1:
                            G.add_node(
                                f"{self.regions[_[0]]}:{counter}",
                                weight=f"{self.regions[_[0]]}:{counter}",
                            )
                            labels[f"{self.regions[_[0]]}:{counter}"] = f"{counter}"
                            G.add_edge(
                                f"{self.regions[_[0]]}:{counter}",
                                0,
                                color="black",
                                weight=100,
                            )

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[_[0]]}:{counter+1}",
                                weight=f"{self.regions[_[0]]}:{counter+1}",
                            )
                            labels[f"{self.regions[_[0]]}:{counter+1}"] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[_[0]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if int(line[26:30]) > 0 or int(line[26:30]) != 0:
                            if flag:
                                if int(line[26:30]) < len(self.strand[_[0]].bases):
                                    extra = int(line[26:30])
                                else:
                                    extra = int(int(line[26:30]) - 4)
                                G.add_edge(before, extra, color="red", weight=200)
                            else:
                                if int(line[26:30]) < len(self.strand[_[0]].bases):
                                    extra = int(line[26:30])
                                else:
                                    extra = int(int(line[26:30]) - 4)
                                if not G.has_edge(extra, before):
                                    if extra != 0:
                                        G.add_edge(
                                            before, extra, color="black", weight=200
                                        )
                        else:
                            flag = False

                        counter += 1

                    else:
                        before = int(line[12:15]) - 3
                        center = int(line[3:6]) - 3
                        if int(line[26:30]) < len(self.strand[_[0]].bases):
                            extra = int(int(line[26:30]) - 1)
                            if extra <= 0:
                                extra = 0
                        else:
                            extra = int(int(line[26:30]) - 4)
                        nodes_list.append(before)

                        if (counter + 1) % 10 == 0:
                            G.add_node(
                                f"{self.regions[_[1]]}:{counter+1}",
                                weight=f"{self.regions[_[1]]}:{counter+1}",
                            )
                            labels[f"{self.regions[_[1]]}:{counter+1}"] = f"{counter+1}"
                            G.add_edge(
                                before,
                                f"{self.regions[_[1]]}:{counter+1}",
                                color="black",
                                weight=100,
                            )

                        if exit == int(line[3:6]):
                            if line[7:8] == "d":
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break
                            else:
                                nodes_list.append(before)
                                G.add_edge(nodes_list[-1], 0, color="black", weight=100)
                                break

                        G.add_edge(before, center, color="black", weight=100)
                        if extra != 0 or extra > 0:
                            if flag:
                                G.add_edge(before, extra, color="red", weight=200)
                            else:
                                if not G.has_edge(extra, before):
                                    G.add_edge(before, extra, color="black", weight=200)
                        else:
                            flag = False

                        counter += 1

                text = self.strand[_[0]].bases + self.strand[_[1]].bases

                for _, t in enumerate(text):
                    G.add_node(nodes_list[_], weight=t)
                    labels[_] = G.nodes[_]["weight"]

                options = {
                    "linewidths": 2,
                    "alpha": 0.8,
                    "node_color": "white",
                    "width": 2,
                    "arrowstyle": "-",
                    "arrowsize": 2,
                    "node_size": 90,
                    "font_size": 8,
                }

                colors = nx.get_edge_attributes(G, "color").values()

                pos = nx.kamada_kawai_layout(G, weight="weight")

                nx.draw(
                    G,
                    pos=pos,
                    with_labels=True,
                    labels=labels,
                    edge_color=colors,
                    **options,
                )

                plt.savefig(e, dpi=300)
                plt.close()
                plt.clf()

        cwd = os.getcwd()
        test = os.listdir(cwd)

        for item in test:
            if item.endswith(f".png"):
                if not item in self.shape:
                    os.remove(os.path.join(cwd, item))

        self.shape.clear()

    def highlight_thief(self):
        """
        This function is used to highlighted the fields responsable for the energy loss binding the different strands.

        Args:
                self.highlighted : a list of sequences that are responsable for the energy loss found in highlight_thief()
                self.index : a list of indices corresponding to the sequences in self.highlighted
        """
        self.highlighted.clear()
        self.index.clear()
        self.shape.clear()

        for i in range(len(self.field)):
            self.field[i].setToolTip("")
            self.field[i].setStyleSheet("background-color:white")

        while len(self.shape) < 2:
            intermediate_process(self)

        if not self.automate:
            self.figure_generation()

        highlighted = []
        highlighted += self.highlighted
        counter = 0
        index = []
        index += self.index
        for d in index:
            if self.header[d].isupper():
                highlighted[counter] = (
                    highlighted[counter][::-1]
                    .replace("C", "temp")
                    .replace("G", "C")
                    .replace("temp", "G")
                )
                highlighted[counter] = (
                    highlighted[counter]
                    .replace("]", "temp")
                    .replace("[", "]")
                    .replace("temp", "[")
                )
                highlighted[counter] = (
                    highlighted[counter]
                    .replace("A", "temp")
                    .replace("T", "A")
                    .replace("temp", "T")
                )

                for _ in range(len(self.header)):
                    if self.header[_] == self.header[d].lower():
                        break
                index[counter] = _
            counter += 1

        flag = False
        counter = 0
        for d in index:
            if counter > len(index):
                break
            if self.field[d].toolTip() != "":
                text = self.field[d].toolTip()
                self.field[d].setToolTip("")
                if flag:
                    if "]" in highlighted[counter]:
                        self.field[d].setToolTip(
                            text + "\n" + highlighted[counter] + "\n"
                        )
                        self.field[d].setStyleSheet("background-color:red")
                        flag = False
                    else:
                        self.field[d].setToolTip(
                            text + "\n" + highlighted[counter] + "\n"
                        )
                        self.field[d].setStyleSheet("background-color:red")

                if "[" in highlighted[counter]:
                    if "]" in highlighted[counter]:
                        self.field[d].setToolTip(
                            text + "\n" + highlighted[counter] + "\n"
                        )

                        self.field[d].setStyleSheet("background-color:red")
                        flag = False
                    else:
                        self.field[d].setToolTip(
                            text + "\n" + highlighted[counter] + "\n"
                        )

                        self.field[d].setStyleSheet("background-color:red")
                        flag = True

            else:
                if flag:
                    if "]" in highlighted[counter]:
                        self.field[d].setToolTip(highlighted[counter] + "\n")

                        self.field[d].setStyleSheet("background-color:red")
                        flag = False
                    else:
                        self.field[d].setToolTip(highlighted[counter] + "\n")
                        self.field[d].setStyleSheet("background-color:red")

                if "[" in highlighted[counter]:
                    if "]" in highlighted[counter]:
                        self.field[d].setToolTip(highlighted[counter] + "\n")

                        self.field[d].setStyleSheet("background-color:red")
                        flag = False
                    else:
                        self.field[d].setToolTip(highlighted[counter] + "\n")
                        self.field[d].setStyleSheet("background-color:red")
                        flag = True
            counter += 1

    def render_structure(self, event):
        """
        This function is responsable for the event handling during a click on a square in the heatmap figure
        """
        self.new_widget = Paint_structure(self)
        try:
            x = int(np.round(event.xdata))
            y = int(np.round(event.ydata))
            self.new_widget.paint(x, y)
        except TypeError:
            pass

    def randomize_strand(self):
        """
        This function is used to automatically correct the energy loss found in calculate().

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.highlighted : a list of sequences that are responsable for the energy loss found in highlight_thief()
                self.index : a list of indices corresponding to the sequences in self.highlighted
                self.header : Region identifiers provided by the user in user_input()
                self.fixed_regions : A dictionary containing the fixed regions as defined by the user in the form of region identifier as key
                                    and associated sequence as item
                self.field : Fields generated by the user in user_input()
        """
        if not self.automate:
            temp = GC_range_picker(self)
            temp.input()
        else:
            try:
                self.run_randomization()
            except StopIteration:
                error = QErrorMessage(self)
                message = list(self.fixed_regions.keys())
                message = [x for x in message if x.islower()]
                message = ", ".join(message)
                error.showMessage(
                    f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                )
                self.progress.setFormat("DONE")
                self.progress.setValue(100)
                self.update()
                clear_files()
                self.btn3.setEnabled(True)
                self.btn8.setEnabled(True)

    def run_randomization(self):
        if self.highlighted == []:
            error = QErrorMessage(self)
            error.showMessage(
                "Please run the calculation once again to highlight regions"
            )

        else:
            self.btn8.setEnabled(False)
            self.progress.setFormat("Randomizing")
            self.trials = 0
            params = {}
            data = gc_content([], self)
            for _ in range(len(self.header)):
                self.input_sequence[self.header[_]] = data[self.header[_]]

            del data
            params["raw_structure"] = self.raw_structure
            params["energy_matrix"] = self.energy
            params["fixed_regions"] = self.fixed_regions
            params["input_sequence_definitions"] = self.input_sequence
            params["highlighted"] = self.highlighted
            params["index"] = self.index
            params["shape"] = self.shape

            self.progress.setValue(int((self.trials / 5) * 100))
            new = 0
            max = 0
            for iteration in range(6):
                flag = False
                counter = 0
                while counter < len(self.highlighted):
                    fields = []

                    for a, highlight in enumerate(self.highlighted):
                        text = ""

                        for b in highlight:
                            if b == "]":
                                flag = False

                            elif flag:
                                text += random.choice(["G", "T", "C", "A"])

                            elif b == "[":
                                flag = True

                            else:
                                text += b

                        fields.append(text)

                    gci = 0
                    for _ in fields[counter]:
                        if _ == "C" or _ == "G":
                            gci += 1

                    if (
                        gci / self.population_size[self.index[counter]]
                    ) < self.gc_min or (
                        gci / self.population_size[self.index[counter]]
                    ) > self.gc_max:
                        if "]" in self.highlighted[counter]:
                            flag = False

                        if (
                            "[" in self.highlighted[counter]
                            and not "]" in self.highlighted[counter]
                        ):
                            flag = True

                        continue

                    else:
                        if (
                            self.header[self.index[counter]]
                            in self.fixed_regions.keys()
                        ):
                            error = QErrorMessage(self)
                            error.showMessage(
                                f"Please make sure to uncheck the field {self.header[self.index[counter]].lower()} to allow modifications"
                            )
                            break

                        if self.index.count(self.index[counter]) > 1:
                            indices = [
                                i
                                for i, x in enumerate(self.index)
                                if x == self.index[counter]
                            ]
                            indices.pop(0)

                            for i in indices:
                                temp = self.highlighted[i]

                                new_indices_o = [
                                    j
                                    for j in range(len(temp))
                                    if temp.startswith("[", j)
                                ]

                                new_indices_c = [
                                    j
                                    for j in range(len(temp))
                                    if temp.startswith("]", j)
                                ]
                                temp = [c for c in fields[counter]]
                                for k in new_indices_o:
                                    temp.insert(k, "[")

                                for l in new_indices_c:
                                    temp.insert(l, "]")

                                temp = "".join(temp)
                                self.highlighted[i] = temp

                        for i in range(len(self.header)):
                            if self.header[self.index[counter]].islower():
                                if (
                                    self.header[i]
                                    == self.header[self.index[counter]].upper()
                                ):
                                    indices = [
                                        j for j, x in enumerate(self.index) if x == i
                                    ]
                                    for k in indices:
                                        temp = self.highlighted[k]
                                        new_indices_o = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("[", j)
                                        ]

                                        new_indices_c = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("]", j)
                                        ]
                                        temp = (
                                            fields[counter][::-1]
                                            .replace("A", "temp")
                                            .replace("T", "A")
                                            .replace("temp", "T")
                                        )
                                        temp = (
                                            temp.replace("C", "temp")
                                            .replace("G", "C")
                                            .replace("temp", "G")
                                        )
                                        temp = [c for c in temp]
                                        for l in new_indices_o:
                                            temp.insert(l, "[")

                                        for m in new_indices_c:
                                            temp.insert(m, "]")

                                        temp = "".join(temp)
                                        self.highlighted[k] = temp

                            if self.header[self.index[counter]].isupper():
                                if (
                                    self.header[i]
                                    == self.header[self.index[counter]].lower()
                                ):
                                    indices = [
                                        j for j, x in enumerate(self.index) if x == i
                                    ]
                                    for k in indices:
                                        temp = self.highlighted[k]

                                        new_indices_o = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("[", j)
                                        ]

                                        new_indices_c = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("]", j)
                                        ]
                                        temp = (
                                            fields[counter][::-1]
                                            .replace("A", "temp")
                                            .replace("T", "A")
                                            .replace("temp", "T")
                                        )
                                        temp = (
                                            temp.replace("C", "temp")
                                            .replace("G", "C")
                                            .replace("temp", "G")
                                        )
                                        temp = [c for c in temp]
                                        for l in new_indices_o:
                                            temp.insert(l, "[")
                                        for m in new_indices_c:
                                            temp.insert(m, "]")

                                        temp = "".join(temp)

                                        self.highlighted[k] = temp

                        self.field[self.index[counter]].setText(fields[counter])
                        self.field[self.index[counter]].setModified(True)
                        self.strand_update()

                        try:
                            if "]" in self.highlighted[counter]:
                                if "[" in self.highlighted[counter]:
                                    counter += 1
                                    continue
                                flag = True
                        except IndexError:
                            pass

                        counter += 1

                higher = 0
                for i in range(len(self.energy)):
                    for j in range(len(self.energy)):
                        if self.energy[i][j] != None:
                            if self.energy[i][j] > higher:
                                higher = self.energy[i][j]

                max = higher

                self.progress.setFormat("Testing randomization")

                self.btn3.setEnabled(False)
                self.automate = True
                self.run_calculation()
                # mfold = Mfold(output_folder="./", mfold_command="mfold_quik")

                # self.energy = [
                #     [None for strand1 in self.strand] for strand2 in self.strand
                # ]

                # data = gc_content([], self)
                # for i, strand1 in enumerate(self.strand):
                #     for j, strand2 in enumerate(self.strand):
                #         region1 = self.regions[i].split("--")
                #         region2 = self.regions[j].swapcase().split("--")
                #         region2 = region2[::-1]

                #         constraint = None
                #         if region1 == region2:
                #             constraint = None

                #         else:
                #             flag = False

                #             if region1[-1] == region2[-1]:
                #                 flag = True

                #             region1 = dict.fromkeys(region1)
                #             region2 = dict.fromkeys(region2[::-1])
                #             length = 1
                #             for key in region1.keys():
                #                 region1[key] = f"{length}-{length + len(data[key]) - 1}"
                #                 length += len(data[key])

                #             length += 3
                #             for key in region2.keys():
                #                 region2[key] = f"{length}-{length + len(data[key]) - 1}"
                #                 length += len(data[key])

                #             shared_list = [
                #                 k for k in region1.keys() if k in region2.keys()
                #             ]
                #             complementary_1 = [
                #                 (k, k.swapcase())
                #                 for k in region1.keys()
                #                 if k.swapcase() in region1.keys()
                #             ]
                #             complementary_2 = [
                #                 (k, k.swapcase())
                #                 for k in region2.keys()
                #                 if k.swapcase() in region2.keys()
                #             ]

                #             if len(shared_list) < 2:
                #                 for key in shared_list:
                #                     if constraint is None:
                #                         constraint = (
                #                             f"P {region1[key]} {region2[key]}\n"
                #                         )
                #                         for value in complementary_1:
                #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                #                         for value in complementary_2:
                #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                #                     else:
                #                         constraint += (
                #                             f"P {region1[key]} {region2[key]}\n"
                #                         )
                #                         for value in complementary_1:
                #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                #                         for value in complementary_2:
                #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                #             else:
                #                 if flag:
                #                     _min = region1[shared_list[0]].split("-")[0]
                #                     _max = region2[shared_list[0]].split("-")[1]
                #                     constraint = f"P {_min}-{_max} {_min}-{_max}\n"
                #                     for value in complementary_1:
                #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                #                     for value in complementary_2:
                #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                #                 else:
                #                     _min_i = region1[shared_list[0]].split("-")[0]
                #                     _max_i = region1[shared_list[-1]].split("-")[1]
                #                     _max_j = region2[shared_list[0]].split("-")[1]
                #                     _min_j = region2[shared_list[-1]].split("-")[0]
                #                     constraint = (
                #                         f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                #                     )
                #                     for value in complementary_1:
                #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                #                     for value in complementary_2:
                #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"

                #         mfold.run(
                #             strand1, strand2, constraint, f"{i}_{j}.seq", f"{i}_{j}.aux"
                #         )

                #         with open(f"{i}_{j}.det", "r") as configfile:
                #             for line in configfile:
                #                 if line.startswith(" dG = "):
                #                     self.energy[i][j] = abs(float(line[10:15]))
                #                     break

                # del data
                higher = 0
                for i in range(len(self.energy)):
                    for j in range(len(self.energy)):
                        if self.energy[i][j] != None:
                            if self.energy[i][j] > higher:
                                higher = self.energy[i][j]

                new = higher
                if new > max and self.trials < 5:
                    while self.center_layout.count() != 0:
                        self.center_layout.removeRow(0)

                    self.header.clear()
                    self.field.clear()
                    self.label.clear()
                    self.check.clear()
                    self.input_sequence = {}

                    self.raw_structure = params["raw_structure"]
                    self.energy = params["energy_matrix"]
                    self.fixed_regions = params["fixed_regions"]
                    self.input_sequence = params["input_sequence_definitions"]
                    self.highlighted = params["highlighted"]
                    self.index = params["index"]
                    self.shape = params["shape"]

                    self.render_form()

                    self.trials += 1
                    self.progress.setValue(int((self.trials / 5) * 100))

                else:
                    break

            flag = False
            if new > max:
                while self.center_layout.count() != 0:
                    self.center_layout.removeRow(0)

                self.header.clear()
                self.field.clear()
                self.label.clear()
                self.check.clear()
                self.input_sequence = {}

                self.raw_structure = params["raw_structure"]
                self.energy = params["energy_matrix"]
                self.fixed_regions = params["fixed_regions"]
                self.input_sequence = params["input_sequence_definitions"]
                self.index = params["index"]
                self.highlighted = params["highlighted"]
                self.shape = params["shape"]

                self.render_form()
                flag = True

            self.progress.setFormat("Generating structures")
            self.progress.setValue(100)
            self.automate = False

            self.run_calculation()
            find_thief(self)
            self.highlight_thief()
            # clear_files()
            self.update()

            self.progress.setFormat("DONE")
            self.btn3.setEnabled(True)
            self.btn8.setEnabled(True)
            if flag:
                if not self.automate:
                    self.failed_randomization()
            clear_files()

    def failed_randomization(self):
        """
        This function is called in case of a failed randomization process
        """
        if self.btn9.isEnabled():
            error = QErrorMessage(self)
            error.showMessage(
                "Randomization failed, please run the randomization once again"
            )

    def loop_calculation(self):
        """
        This function is used to start a widget to help the user specify the number of iterations and gc content range during the loop calculation/randomization process

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
        """
        self.iterator = 0
        if not self.automate:
            temp = Loop_input_widget(self)
            temp.input()
        else:
            try:
                self.run_loop()
                clear_files()
            except StopIteration:
                error = QErrorMessage(self)
                message = list(self.fixed_regions.keys())
                message = [x for x in message if x.islower()]
                message = ", ".join(message)
                error.showMessage(
                    f"Please make sure to uncheck some of these fields: {message} to allow modifications"
                )
                self.progress.setFormat("DONE")
                self.progress.setValue(100)
                self.update()
                clear_files()
                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.file_counter = 0
                self.iterator = 0
                self.automate = False

                self.btn3.setEnabled(True)
                self.btn8.setEnabled(True)
                self.btn9.setEnabled(True)

    def run_loop(self):
        """
        This function is used to create iteration in the process of lowering energy loss by create loops of calculation and randomization.

        Args:
                self.automate : a flag used to bypass and automate calculate() and loop_calculation()
                self.iterator : a user input that determinates how many iterations are needed
                self.file_counter : a counter for the current iteration in loop_calculation()
                self.progress : a progressbar component used in the main layout
                self.field : Fields generated by the user in user_input()
        """
        if isinstance(self.iterator, int):
            if self.iterator <= 0:
                error = QErrorMessage(self)
                error.showMessage(
                    f"Please make sure to provide an integer value greater than 0"
                )

            elif self.field == []:
                error = QErrorMessage(self)
                error.showMessage(f"Please make sure to provide a structure")

            else:
                self.btn9.setEnabled(False)
                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.automate = True
                self.trials = 0
                self.progress.setFormat("Calculating")
                self.btn3.setEnabled(False)
                self.btn8.setEnabled(False)
                for count in range(self.iterator):
                    self.progress.setValue(
                        int((self.file_counter / self.iterator) * 100)
                    )

                    self.automate = True

                    # mfold = Mfold(output_folder="./", mfold_command="mfold_quik")

                    # self.energy = [
                    #     [None for strand1 in self.strand] for strand2 in self.strand
                    # ]

                    # data = gc_content([], self)
                    # for a, strand1 in enumerate(self.strand):
                    #     for b, strand2 in enumerate(self.strand):
                    #         region1 = self.regions[a].split("--")
                    #         region2 = self.regions[b].swapcase().split("--")
                    #         region2 = region2[::-1]

                    #         constraint = None
                    #         if region1 == region2:
                    #             constraint = None

                    #         else:
                    #             flag = False

                    #             if region1[-1] == region2[-1]:
                    #                 flag = True

                    #             region1 = dict.fromkeys(region1)
                    #             region2 = dict.fromkeys(region2[::-1])
                    #             length = 1
                    #             for key in region1.keys():
                    #                 region1[
                    #                     key
                    #                 ] = f"{length}-{length + len(data[key]) - 1}"
                    #                 length += len(data[key])

                    #             length += 3
                    #             for key in region2.keys():
                    #                 region2[
                    #                     key
                    #                 ] = f"{length}-{length + len(data[key]) - 1}"
                    #                 length += len(data[key])

                    #             shared_list = [
                    #                 k for k in region1.keys() if k in region2.keys()
                    #             ]
                    #             complementary_1 = [
                    #                 (k, k.swapcase())
                    #                 for k in region1.keys()
                    #                 if k.swapcase() in region1.keys()
                    #             ]
                    #             complementary_2 = [
                    #                 (k, k.swapcase())
                    #                 for k in region2.keys()
                    #                 if k.swapcase() in region2.keys()
                    #             ]

                    #             if len(shared_list) < 2:
                    #                 for key in shared_list:
                    #                     if constraint is None:
                    #                         constraint = (
                    #                             f"P {region1[key]} {region2[key]}\n"
                    #                         )
                    #                         for value in complementary_1:
                    #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    #                         for value in complementary_2:
                    #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                    #                     else:
                    #                         constraint += (
                    #                             f"P {region1[key]} {region2[key]}\n"
                    #                         )
                    #                         for value in complementary_1:
                    #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    #                         for value in complementary_2:
                    #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                    #             else:
                    #                 if flag:
                    #                     _min = region1[shared_list[0]].split("-")[0]
                    #                     _max = region2[shared_list[0]].split("-")[1]
                    #                     constraint = f"P {_min}-{_max} {_min}-{_max}\n"
                    #                     for value in complementary_1:
                    #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    #                     for value in complementary_2:
                    #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                    #                 else:
                    #                     _min_i = region1[shared_list[0]].split("-")[0]
                    #                     _max_i = region1[shared_list[-1]].split("-")[1]
                    #                     _max_j = region2[shared_list[0]].split("-")[1]
                    #                     _min_j = region2[shared_list[-1]].split("-")[0]
                    #                     constraint = (
                    #                         f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                    #                     )
                    #                     for value in complementary_1:
                    #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                    #                     for value in complementary_2:
                    #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"

                    #         mfold.run(
                    #             strand1,
                    #             strand2,
                    #             constraint,
                    #             f"{a}_{b}.seq",
                    #             f"{a}_{b}.aux",
                    #         )
                    #         with open(f"{a}_{b}.det", "r") as configfile:
                    #             for line in configfile:
                    #                 if line.startswith(" dG = "):
                    #                     self.energy[a][b] = abs(float(line[10:15]))
                    #                     break
                    self.progress.setFormat("Calculating")
                    self.run_calculation()
                    find_thief(self)
                    self.highlighted.clear()
                    self.index.clear()
                    self.shape.clear()
                    # del data

                    for _ in range(2):
                        intermediate_process(self)

                    self.progress.setFormat("Randomizing")

                    params = {}
                    data = gc_content([], self)
                    for _ in range(len(self.header)):
                        self.input_sequence[self.header[_]] = data[self.header[_]]

                    del data
                    params["raw_structure"] = self.raw_structure
                    params["fixed_regions"] = self.fixed_regions
                    params["input_sequence_definitions"] = self.input_sequence
                    params["energy_matrix"] = self.energy
                    params["highlighted"] = self.highlighted
                    params["index"] = self.index
                    params["shape"] = self.shape

                    new = 0
                    max = 0

                    for iteration in range(6):
                        flag = False
                        counter = 0
                        while counter < len(self.highlighted):
                            fields = []

                            for a, highlight in enumerate(self.highlighted):
                                text = ""

                                for b in highlight:
                                    if b == "]":
                                        flag = False

                                    elif flag:
                                        text += random.choice(["G", "T", "C", "A"])

                                    elif b == "[":
                                        flag = True

                                    else:
                                        text += b

                                fields.append(text)

                            gci = 0
                            for _ in fields[counter]:
                                if _ == "C" or _ == "G":
                                    gci += 1

                            if (
                                gci / self.population_size[self.index[counter]]
                            ) < self.gc_min or (
                                gci / self.population_size[self.index[counter]]
                            ) > self.gc_max:
                                if "]" in self.highlighted[counter]:
                                    flag = False

                                if (
                                    "[" in self.highlighted[counter]
                                    and not "]" in self.highlighted[counter]
                                ):
                                    flag = True

                                continue

                            else:
                                if (
                                    self.header[self.index[counter]]
                                    in self.fixed_regions.keys()
                                ):
                                    error = QErrorMessage(self)
                                    error.showMessage(
                                        f"Please make sure to uncheck the field {self.header[self.index[counter]].lower()} to allow modifications"
                                    )
                                    break

                                if self.index.count(self.index[counter]) > 1:
                                    indices = [
                                        i
                                        for i, x in enumerate(self.index)
                                        if x == self.index[counter]
                                    ]
                                    indices.pop(0)

                                    for i in indices:
                                        temp = self.highlighted[i]

                                        new_indices_o = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("[", j)
                                        ]

                                        new_indices_c = [
                                            j
                                            for j in range(len(temp))
                                            if temp.startswith("]", j)
                                        ]
                                        temp = [c for c in fields[counter]]
                                        for k in new_indices_o:
                                            temp.insert(k, "[")

                                        for l in new_indices_c:
                                            temp.insert(l, "]")

                                        temp = "".join(temp)
                                        self.highlighted[i] = temp

                                for i in range(len(self.header)):
                                    if self.header[self.index[counter]].islower():
                                        if (
                                            self.header[i]
                                            == self.header[self.index[counter]].upper()
                                        ):
                                            indices = [
                                                j
                                                for j, x in enumerate(self.index)
                                                if x == i
                                            ]
                                            for _ in indices:
                                                temp = self.highlighted[_]
                                                new_indices_o = [
                                                    j
                                                    for j in range(len(temp))
                                                    if temp.startswith("[", j)
                                                ]

                                                new_indices_c = [
                                                    j
                                                    for j in range(len(temp))
                                                    if temp.startswith("]", j)
                                                ]
                                                temp = (
                                                    fields[counter][::-1]
                                                    .replace("A", "temp")
                                                    .replace("T", "A")
                                                    .replace("temp", "T")
                                                )
                                                temp = (
                                                    temp.replace("C", "temp")
                                                    .replace("G", "C")
                                                    .replace("temp", "G")
                                                )
                                                temp = [c for c in temp]
                                                for l in new_indices_o:
                                                    temp.insert(l, "[")

                                                for m in new_indices_c:
                                                    temp.insert(m, "]")

                                                temp = "".join(temp)
                                                self.highlighted[_] = temp

                                    if self.header[self.index[counter]].isupper():
                                        if (
                                            self.header[i]
                                            == self.header[self.index[counter]].lower()
                                        ):
                                            indices = [
                                                j
                                                for j, x in enumerate(self.index)
                                                if x == i
                                            ]
                                            for k in indices:
                                                temp = self.highlighted[k]

                                                new_indices_o = [
                                                    j
                                                    for j in range(len(temp))
                                                    if temp.startswith("[", j)
                                                ]

                                                new_indices_c = [
                                                    j
                                                    for j in range(len(temp))
                                                    if temp.startswith("]", j)
                                                ]
                                                temp = (
                                                    fields[counter][::-1]
                                                    .replace("A", "temp")
                                                    .replace("T", "A")
                                                    .replace("temp", "T")
                                                )
                                                temp = (
                                                    temp.replace("C", "temp")
                                                    .replace("G", "C")
                                                    .replace("temp", "G")
                                                )
                                                temp = [c for c in temp]
                                                for l in new_indices_o:
                                                    temp.insert(l, "[")
                                                for m in new_indices_c:
                                                    temp.insert(m, "]")

                                                temp = "".join(temp)

                                                self.highlighted[k] = temp

                                self.field[self.index[counter]].setText(fields[counter])
                                self.field[self.index[counter]].setModified(True)
                                self.strand_update()

                                try:
                                    if "]" in self.highlighted[counter]:
                                        if "[" in self.highlighted[counter]:
                                            counter += 1
                                            continue
                                        flag = True
                                except IndexError:
                                    pass

                                counter += 1

                        higher = 0
                        for i in range(len(self.energy)):
                            for j in range(len(self.energy)):
                                if self.energy[i][j] != None:
                                    if self.energy[i][j] > higher:
                                        higher = self.energy[i][j]

                        max = higher

                        self.automate = True
                        self.run_calculation()
                        # mfold = Mfold(output_folder="./", mfold_command="mfold_quik")

                        # self.energy = [
                        #     [None for strand1 in self.strand] for strand2 in self.strand
                        # ]

                        # data = gc_content([], self)
                        # for i, strand1 in enumerate(self.strand):
                        #     for j, strand2 in enumerate(self.strand):
                        #         region1 = self.regions[i].split("--")
                        #         region2 = self.regions[j].swapcase().split("--")
                        #         region2 = region2[::-1]

                        #         constraint = None
                        #         if region1 == region2:
                        #             constraint = None

                        #         else:
                        #             flag = False

                        #             if region1[-1] == region2[-1]:
                        #                 flag = True

                        #             region1 = dict.fromkeys(region1)
                        #             region2 = dict.fromkeys(region2[::-1])
                        #             length = 1
                        #             for key in region1.keys():
                        #                 region1[
                        #                     key
                        #                 ] = f"{length}-{length + len(data[key]) - 1}"
                        #                 length += len(data[key])

                        #             length += 3
                        #             for key in region2.keys():
                        #                 region2[
                        #                     key
                        #                 ] = f"{length}-{length + len(data[key]) - 1}"
                        #                 length += len(data[key])

                        #             shared_list = [
                        #                 k for k in region1.keys() if k in region2.keys()
                        #             ]

                        #             complementary_1 = [
                        #                 (k, k.swapcase())
                        #                 for k in region1.keys()
                        #                 if k.swapcase() in region1.keys()
                        #             ]
                        #             complementary_2 = [
                        #                 (k, k.swapcase())
                        #                 for k in region2.keys()
                        #                 if k.swapcase() in region2.keys()
                        #             ]

                        #             if len(shared_list) < 2:
                        #                 for key in shared_list:
                        #                     if constraint is None:
                        #                         constraint = (
                        #                             f"P {region1[key]} {region2[key]}\n"
                        #                         )
                        #                         for value in complementary_1:
                        #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                        #                         for value in complementary_2:
                        #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                        #                     else:
                        #                         constraint += (
                        #                             f"P {region1[key]} {region2[key]}\n"
                        #                         )
                        #                         for value in complementary_1:
                        #                             constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                        #                         for value in complementary_2:
                        #                             constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                        #             else:
                        #                 if flag:
                        #                     _min = region1[shared_list[0]].split("-")[0]
                        #                     _max = region2[shared_list[0]].split("-")[1]
                        #                     constraint = (
                        #                         f"P {_min}-{_max} {_min}-{_max}\n"
                        #                     )
                        #                     for value in complementary_1:
                        #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                        #                     for value in complementary_2:
                        #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"
                        #                 else:
                        #                     _min_i = region1[shared_list[0]].split("-")[
                        #                         0
                        #                     ]
                        #                     _max_i = region1[shared_list[-1]].split(
                        #                         "-"
                        #                     )[1]
                        #                     _max_j = region2[shared_list[0]].split("-")[
                        #                         1
                        #                     ]
                        #                     _min_j = region2[shared_list[-1]].split(
                        #                         "-"
                        #                     )[0]
                        #                     constraint = f"P {_min_i}-{_max_i} {_min_j}-{_max_j}\n"
                        #                     for value in complementary_1:
                        #                         constraint += f"P {region1[value[0]]} {region1[value[1]]}\n"
                        #                     for value in complementary_2:
                        #                         constraint += f"P {region2[value[0]]} {region2[value[1]]}\n"

                        #         mfold.run(
                        #             strand1,
                        #             strand2,
                        #             constraint,
                        #             f"{i}_{j}.seq",
                        #             f"{i}_{j}.aux",
                        #         )
                        #         with open(f"{i}_{j}.det", "r") as configfile:
                        #             for line in configfile:
                        #                 if line.startswith(" dG = "):
                        #                     self.energy[i][j] = abs(float(line[10:15]))
                        #                     break

                        # del data
                        higher = 0
                        for i in range(len(self.energy)):
                            for j in range(len(self.energy)):
                                if self.energy[i][j] != None:
                                    if self.energy[i][j] > higher:
                                        higher = self.energy[i][j]

                        new = higher
                        if new > max and self.trials < 5:
                            while self.center_layout.count() != 0:
                                self.center_layout.removeRow(0)

                            self.header.clear()
                            self.field.clear()
                            self.label.clear()
                            self.check.clear()
                            self.input_sequence = {}

                            self.raw_structure = params["raw_structure"]
                            self.energy = params["energy_matrix"]
                            self.fixed_regions = params["fixed_regions"]
                            self.input_sequence = params["input_sequence_definitions"]
                            self.highlighted = params["highlighted"]
                            self.index = params["index"]
                            self.shape = params["shape"]

                            self.render_form()

                            self.trials += 1

                        else:
                            break

                    if new > max:
                        while self.center_layout.count() != 0:
                            self.center_layout.removeRow(0)

                        self.header.clear()
                        self.field.clear()
                        self.label.clear()
                        self.check.clear()
                        self.input_sequence = {}
                        self.raw_structure = params["raw_structure"]
                        self.energy = params["energy_matrix"]
                        self.fixed_regions = params["fixed_regions"]
                        self.input_sequence = params["input_sequence_definitions"]
                        self.highlighted = params["highlighted"]
                        self.index = params["index"]
                        self.shape = params["shape"]

                        self.render_form()

                    self.file_counter += 1

                self.highlighted.clear()
                self.index.clear()
                self.shape.clear()

                self.file_counter = 0
                self.iterator = 0

                self.progress.setFormat("Generating structures")
                self.progress.setValue(100)
                self.automate = False

                self.run_calculation()
                find_thief(self)
                self.highlight_thief()
                # clear_files()
                self.update()
                self.progress.setFormat("DONE")

                clear_files()
                self.btn9.setEnabled(True)
                self.btn8.setEnabled(True)
                self.btn3.setEnabled(True)

    def output_data(self):
        """
        This function is used to export the heatmap energy matrix in a ".csv" file.

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region provided by the user in user_input()
        """
        filename = QFileDialog.getSaveFileName(
            self,
            "Save configuration",
            "/bureau/dna-origami",
        )

        if filename[0]:
            if self.energy == []:
                error = QErrorMessage(self)
                error.showMessage(f"There is no heatmap plot at the moment")
            else:
                try:
                    with open(filename[0] + ".csv", "w") as configfile:
                        columns = self.regions
                        df = pd.DataFrame(self.energy, columns=columns)
                        df.to_csv(configfile, index=False)
                except FileNotFoundError:
                    pass

    def update(self):
        """
        This function is used to generate the heatmap from the energy matrix found in calculate().

        Args:
                self.energy : Matrix used to store the energy loss returned by the Mfold program
                self.regions : Region class used to define the regions defined
                self.canvas : A matplotlib figure class to draw the heatmap from the energy matrix stored in calculate()
                self.max : A value set by the user to rescale the heatmap max value
        """
        if self.energy == []:
            error = QErrorMessage(self)
            error.showMessage(f"The energy matrix is empty!")
        else:
            self.canvas.figure.clear()
            ax = self.canvas.figure.add_subplot(111)
            a = self.energy

            ticks = self.regions

            if self.max != 0:
                try:
                    im = ax.imshow(
                        a, cmap="plasma", interpolation="nearest", vmax=self.max
                    )
                except (TypeError, UnboundLocalError):
                    self.update()

            else:
                try:
                    im = ax.imshow(a, cmap="plasma", interpolation="nearest")
                except (TypeError, UnboundLocalError):
                    self.update()

            ax.set_xticks(np.arange(len(ticks)))
            ax.set_yticks(np.arange(len(ticks)))
            ax.set_xticklabels(
                ticks, fontsize=10, rotation=45, ha="right", linespacing=2
            )
            ax.set_yticklabels(ticks, fontsize=10)

            ax.figure.colorbar(
                im,
                label="Kcal/mol",
                orientation="vertical",
            )

            cwd = os.getcwd()
            test = os.listdir(cwd)

            structure = {}
            to_avoid = ""
            for count in range(2):
                for item in test:
                    if item.endswith(".png"):
                        item = item.replace(".png", "")
                        i = int(item.split("_")[0])
                        j = int(item.split("_")[1])
                        if to_avoid != "":
                            if i != int(to_avoid.split("-")[0]) or j != int(
                                to_avoid.split("-")[1]
                            ):
                                structure[count] = {"x": i, "y": j}
                        else:
                            structure[count] = {"x": i, "y": j}

                to_avoid = str(structure[count]["x"]) + "-" + str(structure[count]["y"])

            # print(structure)
            # to_avoid = ""
            # structure = {}
            # for count in range(2):
            #     higher = 0
            #     for i in range(len(self.energy)):
            #         for j in range(len(self.energy)):
            #             if self.energy[i][j] != None:
            #                 if to_avoid != "":
            #                     if self.energy[i][j] > higher and (
            #                         i != int(to_avoid.split("-")[0])
            #                         or j != int(to_avoid.split("-")[1])
            #                     ):
            #                         higher = self.energy[i][j]
            #                         structure[count] = {"x": i, "y": j}
            #                 else:
            #                     if self.energy[i][j] > higher:
            #                         higher = self.energy[i][j]
            #                         structure[count] = {"x": i, "y": j}

            #     to_avoid = str(structure[count]["x"]) + "-" + str(structure[count]["y"])

            for _ in range(len(structure)):
                ax.add_patch(
                    Rectangle(
                        (structure[_]["y"] - 0.5, structure[_]["x"] - 0.5),
                        1,
                        1,
                        edgecolor="red",
                        fill=False,
                        lw=3,
                    )
                )

            ax.format_coord = lambda x, y: f"Energy"

            self.canvas.draw()

    def closeEvent(self, event):
        """
        This function is used to close/exit the main widget.
        """
        exit = QMessageBox()
        reply = exit.question(
            self,
            "Confirmation step",
            "Are you sure to quit?",
            QMessageBox.Yes | QMessageBox.No,
            0,
        )
        if reply == QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()


if __name__ == "__main__":
    window = QApplication(sys.argv)
    view = DNA_origami()
    sys.exit(window.exec_())
